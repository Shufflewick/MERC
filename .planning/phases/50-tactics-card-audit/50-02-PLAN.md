---
phase: 50-tactics-card-audit
plan: 02
type: execute
wave: 2
depends_on: ["50-01"]
files_modified:
  - src/rules/tactics-effects.ts
  - src/ui/components/GameTable.vue
autonomous: true

must_haves:
  truths:
    - "When any tactics card is played, a visible banner appears showing the card name"
    - "The game board shows pre-animation state while the tactics banner is displayed"
    - "All 12 working tactics effects fire animations when executed"
    - "GameTable.vue has registered animation handlers for all 12 tactics animation events"
  artifacts:
    - path: "src/rules/tactics-effects.ts"
      provides: "game.animate() calls in 12 working effect functions"
      contains: "game.animate"
    - path: "src/ui/components/GameTable.vue"
      provides: "Animation handler registrations for tactics events"
      contains: "registerHandler.*tactic"
  key_links:
    - from: "src/rules/tactics-effects.ts"
      to: "game.animate()"
      via: "BoardSmith animation system"
      pattern: "game\\.animate\\("
    - from: "src/ui/components/GameTable.vue"
      to: "animation event handlers"
      via: "registerHandler"
      pattern: "registerHandler.*tactic"
---

<objective>
Add visible animations to all 12 correctly-implemented tactics card effects and register their animation handlers in GameTable.vue.

Purpose: Currently zero tactics cards have any animation. When a card is played, the state changes happen silently. Each card should fire a `game.animate()` event so the UI can show what happened.

Output: All 12 working tactics effects call `game.animate()` with pre-computed data and mutations in callback. GameTable.vue registers handlers for each event type.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/50-tactics-card-audit/50-RESEARCH.md
@.planning/phases/50-tactics-card-audit/50-01-SUMMARY.md
@src/rules/tactics-effects.ts
@src/ui/components/GameTable.vue (lines 485-558 — animation handler pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add game.animate() to sector-targeted tactics effects (8 cards)</name>
  <files>
    src/rules/tactics-effects.ts
  </files>
  <action>
For each of these 8 sector-targeted effect functions, wrap the state mutations inside a `game.animate()` call. Follow the pattern documented in MEMORY.md and used by mortar-strike/combat-panel:

**Critical pattern rules (from MEMORY.md):**
- Pre-compute data BEFORE `game.animate()` call
- All state mutations go INSIDE the callback (captured for theatre view)
- Pure UI signals with no mutations use empty callback: `game.animate('type', data, () => {})`

**Cards to update (sector-targeted — show affected sectors on map):**

1. `artilleryBarrage` — Already has sector targeting logic. Add `game.animate('tactic-artillery-barrage', { cardName: 'Artillery Barrage', sectorsTargeted: sectorRolls.map(s => ({ sectorId: s.sector.sectorId, sectorName: s.sector.sectorName, hits: s.hits })) }, () => {})` BEFORE the pending state is set. This is a pure UI signal since mutations happen through the allocation flow.

2. `familyThreat` — Pre-compute `affectedSectors` array with sectorId/sectorName/removed counts. Wrap the militia removal loop inside `game.animate('tactic-family-threat', { cardName: 'Family Threat', affectedSectors }, () => { /* removal mutations here */ })`.

3. `fodder` — Pre-compute target sectors and militia counts. Wrap the militia placement + combat queueing inside `game.animate('tactic-fodder', { cardName: 'Fodder', targets: [...] }, () => { /* mutations */ })`.

4. `reinforcements` — Pre-compute which industries get reinforced. Wrap militia additions inside `game.animate('tactic-reinforcements', { cardName: 'Reinforcements', sectors: [...] }, () => { /* mutations */ })`.

5. `seizure` — Pre-compute which wilderness sectors will flip. Wrap explore + militia placement inside `game.animate('tactic-seizure', { cardName: 'Seizure', sectors: [...] }, () => { /* mutations */ })`.

6. `sentry` — Pre-compute which uncontrolled sectors get militia. Wrap placement inside `game.animate('tactic-sentry', { cardName: 'Sentry', sectors: [...] }, () => { /* mutations */ })`.

7. `blockTrade` — Pre-compute which cities flip and militia counts. Wrap city explore + militia inside `game.animate('tactic-block-trade', { cardName: 'Block Trade', cities: [...] }, () => { /* mutations */ })`. Note: This function was updated by plan 01 to add militia placement. Read it before modifying.

8. `taintedWater` — Pre-compute militia removal counts and MERC damage targets. Wrap mutations inside `game.animate('tactic-tainted-water', { cardName: 'Tainted Water', sectors: [...], mercs: [...] }, () => { /* mutations */ })`.

For each animation event, include the card name in the data so the UI can display it: `{ cardName: 'Family Threat', ...specificData }`.

**Do NOT touch** the `generalisimo` and `lockdown` functions — they will be completely rewritten in plans 03 and 04.
**Do NOT touch** the `revealBase` function — it's a helper, not a card effect.
  </action>
  <verify>
    Run `npx vitest run` — all tests pass. Grep for `game.animate` in tactics-effects.ts — should find 8 occurrences for these sector-targeted cards.
  </verify>
  <done>
    All 8 sector-targeted tactics card effects call game.animate() with appropriate pre-computed data and mutations in callbacks. Theatre view correctly shows pre-animation state for each card.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add game.animate() to banner/flag tactics effects (4 cards)</name>
  <files>
    src/rules/tactics-effects.ts
  </files>
  <action>
For these 4 banner/flag effect functions, add `game.animate()` calls. These set persistent boolean flags with no sector-visible board change, so the animation is a banner announcement.

**Cards to update (banner/flag — permanent effects, no board-visible change):**

1. `betterWeapons` — The state mutation is just setting a boolean flag. The `revealBase()` call should happen BEFORE animate. Use `game.animate('tactic-better-weapons', { cardName: 'Better Weapons', effectName: 'Better Weapons', description: 'Militia now hit on 3+' }, () => { game.betterWeaponsActive = true; })`.

2. `veteranMilitia` — Same pattern. The `revealBase()` call should happen BEFORE animate. Use `game.animate('tactic-veteran-militia', { cardName: 'Veteran Militia', effectName: 'Veteran Militia', description: 'Militia +1 initiative' }, () => { game.veteranMilitiaActive = true; })`.

3. `conscripts` — `game.animate('tactic-conscripts', { cardName: 'Conscripts', effectName: 'Conscripts', amount: Math.ceil(game.rebelCount / 2) }, () => { game.conscriptsActive = true; game.conscriptsAmount = Math.ceil(game.rebelCount / 2); })`.

4. `oilReserves` — `game.animate('tactic-oil-reserves', { cardName: 'Oil Reserves', effectName: 'Oil Reserves', description: 'Oil controller gets free action' }, () => { game.oilReservesActive = true; })`.

**Do NOT touch** the `generalisimo` and `lockdown` functions — they will be completely rewritten in plans 03 and 04.
**Do NOT touch** the `revealBase` function — it's a helper, not a card effect.
  </action>
  <verify>
    Run `npx vitest run` — all tests pass. Grep for `game.animate` in tactics-effects.ts — combined with Task 1, should find 12 occurrences total (8 sector-targeted + 4 banner/flag), excluding generalisimo and lockdown.
  </verify>
  <done>
    All 4 banner/flag tactics card effects call game.animate() with announcement data and mutations in callbacks.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register animation handlers in GameTable.vue for all 12 tactics events</name>
  <files>
    src/ui/components/GameTable.vue
  </files>
  <action>
In the `if (animationEvents)` block in GameTable.vue (currently around line 525), register handlers for each tactics animation event. Follow the mortar-strike handler pattern.

**For sector-targeted events** (tactic-artillery-barrage, tactic-family-threat, tactic-fodder, tactic-reinforcements, tactic-seizure, tactic-sentry, tactic-block-trade, tactic-tainted-water):

Create a single reactive ref `activeTacticEvent` to hold the current tactic animation data:
```typescript
const activeTacticEvent = ref<{
  type: string;
  cardName: string;
  data: Record<string, unknown>;
} | null>(null);
let tacticEventResolve: (() => void) | null = null;
```

Register a handler for each event type. Each handler sets `activeTacticEvent.value` with the event data and auto-dismisses after a timeout:
```typescript
animationEvents.registerHandler('tactic-family-threat', async (event) => {
  activeTacticEvent.value = { type: 'family-threat', cardName: 'Family Threat', data: event.data as Record<string, unknown> };
  await new Promise<void>((resolve) => {
    setTimeout(() => {
      activeTacticEvent.value = null;
      resolve();
    }, 2000);
  });
});
```

Register all 12 event types (8 sector-targeted + 4 banner/flag) with appropriate card names. Use the same auto-dismiss pattern for all of them for now — dedicated animation components can be built later if needed.

**For banner/flag events** (tactic-better-weapons, tactic-veteran-militia, tactic-conscripts, tactic-oil-reserves):
Same pattern, but use a slightly longer timeout (2500ms) since these are "permanent effect" announcements.

Add a computed property `hasTacticEvent` that checks `activeTacticEvent.value !== null`.

Add a simple banner display in the template section that shows the tactic card name and brief description when `hasTacticEvent` is true. Position it as a centered overlay (similar to the game-over overlay pattern). Style with Tailwind:
```html
<div v-if="activeTacticEvent" class="absolute inset-0 flex items-center justify-center z-50 pointer-events-none">
  <div class="bg-red-900/90 text-white px-8 py-4 rounded-lg shadow-2xl text-center animate-pulse">
    <div class="text-2xl font-bold">{{ activeTacticEvent.cardName }}</div>
    <div class="text-sm mt-1 opacity-80">Dictator Tactics</div>
  </div>
</div>
```

This gives every tactics card a visible "card played" banner animation. More elaborate per-card animations (explosions for artillery, fleeing icons for family threat, etc.) can be added later as polish.
  </action>
  <verify>
    No TypeScript errors in GameTable.vue. The component template correctly references `activeTacticEvent`. Count that 12 registerHandler calls exist for tactic events.
  </verify>
  <done>
    GameTable.vue registers animation handlers for all 12 tactics events and displays a visible banner when any tactics card is played. The animation system is wired end-to-end.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run` passes
2. `grep -c "game.animate" src/rules/tactics-effects.ts` returns 12 (excluding generalisimo and lockdown which are untouched)
3. `grep -c "registerHandler.*tactic" src/ui/components/GameTable.vue` returns 12
4. No TypeScript errors: `npx tsc --noEmit` passes (or project-specific type check)
</verification>

<success_criteria>
- All 12 working tactics cards fire visible animations
- GameTable.vue shows a banner overlay for each tactic played
- Theatre view correctly freezes pre-animation state
- No regressions in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/50-tactics-card-audit/50-02-SUMMARY.md`
</output>
