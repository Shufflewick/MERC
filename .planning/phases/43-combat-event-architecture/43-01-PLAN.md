---
phase: 43-combat-event-architecture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/rules/combat.ts
  - src/rules/actions/rebel-combat.ts
autonomous: true

must_haves:
  truths:
    - "All 13 game.animate() calls in the combat system are pure data -- no callbacks"
    - "Combat mechanics are unchanged -- same damage, same deaths, same healing, same state"
    - "All 76+ existing combat tests pass with zero regressions"
  artifacts:
    - path: "src/rules/combat.ts"
      provides: "10 pure-data animate calls (callbacks removed)"
      contains: "game.animate\\('combat-"
    - path: "src/rules/actions/rebel-combat.ts"
      provides: "3 pure-data animate calls (callbacks removed)"
      contains: "game.animate\\('combat-heal'"
  key_links:
    - from: "combat-damage animate"
      to: "applyDamage call"
      via: "applyDamage runs immediately after game.animate, not inside callback"
      pattern: "game\\.animate\\('combat-damage'.*\\);\\s*\\n\\s*applyDamage"
    - from: "combat-death animate"
      to: "casualties.push"
      via: "casualties.push runs immediately after game.animate, not inside callback"
      pattern: "game\\.animate\\('combat-death'.*\\);\\s*\\n\\s*casualties\\.push"
    - from: "combat-heal animate"
      to: "target healing mutations"
      via: "healing mutations run immediately after game.animate, not inside callback"
      pattern: "game\\.animate\\('combat-heal'.*\\);\\s*\\n"
---

<objective>
Extract all mutations from game.animate() callbacks into normal code after the animate call, making every combat animation event pure data.

Purpose: SRV-03 requires all animate calls to be pure data events with no callbacks. This is the prerequisite for Phase 44's CombatPanel rebuild -- the UI needs to trust that animation events carry complete, pre-computed data and that no mutations happen inside callbacks. Currently 11 of 13 animate calls have mutation callbacks (2 combat-roll calls are already pure).

Output: combat.ts and rebel-combat.ts with all 13 animate calls as pure data. Zero test regressions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-combat-event-architecture/43-RESEARCH.md
@src/rules/combat.ts
@src/rules/actions/rebel-combat.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract mutations from all 10 animate callbacks in combat.ts</name>
  <files>src/rules/combat.ts</files>
  <action>
For each animate call, move the callback body to immediately after the `game.animate()` call and remove the callback parameter. Keep mutations in the exact same order. The callback runs synchronously so timing is unchanged -- but you MUST keep mutations immediately after the animate call with no unrelated code between them.

**Call 1: combat-attack-dog (AI auto-assign) ~line 1076**
Move callback body after animate:
```
game.animate('combat-attack-dog', { ... });
dog.attackDogAssignedTo = target.id;
dog.attackDogTargetName = target.name.charAt(0).toUpperCase() + target.name.slice(1);
dogState.assignments.set(target.id, dog);
dogState.dogs.push(dog);
attacker.hasAttackDog = false;
game.message(`${attacker.name} releases Attack Dog on ${target.name}!`);
game.message(`${target.name} must attack the dog before doing anything else.`);
```

**Call 2: combat-attack-dog (human pre-selected) ~line 1127**
Same pattern as Call 1 -- move identical callback body after animate.

**Call 3: combat-attack-dog (human pre-selected, existing dog) ~line 1485**
Most complex callback. Move ALL operations after animate:
```
game.animate('combat-attack-dog', { ... });
existingDog.attackDogAssignedTo = target.id;
existingDog.attackDogTargetName = target.name.charAt(0).toUpperCase() + target.name.slice(1);
existingDog.attackDogPendingTarget = false;
activeDogState.assignments.set(target.id, existingDog);
const combatantArrays = existingDog.isDictatorSide ? dictatorSide : rebels;
const dogInCombatants = combatantArrays.find(c => c.id === existingDog.id);
if (dogInCombatants) {
  dogInCombatants.attackDogAssignedTo = target.id;
  dogInCombatants.attackDogTargetName = existingDog.attackDogTargetName;
  dogInCombatants.attackDogPendingTarget = false;
}
game.message(`${attacker.name} releases Attack Dog on ${target.name}!`);
game.message(`${target.name} must attack the dog before doing anything else.`);
attacker.hasAttackDog = false;
```

**Calls 4 & 5: combat-roll (initial + reroll) ~lines 1644, 1664**
Already pure data with `() => {}` callbacks. Remove the empty callbacks entirely (omit the third argument).

**Call 6: combat-damage ~line 1797**
CRITICAL: Keep `applyDamage(target, remainingHits, game, attacker.armorPiercing)` exactly as-is. Do NOT substitute `expectedHealthDamage` for `remainingHits`. The `applyDamage` function handles armor absorption internally.
```
game.animate('combat-damage', { ... });
applyDamage(target, remainingHits, game, attacker.armorPiercing);
damageDealt.set(target.id, expectedHealthDamage);
if (target.sourceElement?.isMerc) {
  const merc = target.sourceElement;
  merc.damage = merc.maxHealth - target.health;
}
```

**Call 7: combat-death (Adelheid fallback) ~line 1844**
```
game.animate('combat-death', { ... });
casualties.push(target);
game.message(`${attacker.name} kills ${target.name}!`);
```

**Call 8: combat-death (normal) ~line 1854**
Same pattern as Call 7.

**Call 9: combat-round-start ~line 2445**
```
game.animate('combat-round-start', { round });
if (game.activeCombat?.healingDiceUsed) {
  game.activeCombat.healingDiceUsed.clear();
}
```

**Call 10: combat-end ~line 2773**
The callback `game.activeCombat = combatEndState` is redundant with line 2770 which already sets it before the animate call. Simply remove the callback entirely.
```
game.animate('combat-end', {
  rebelVictory: outcome.rebelVictory,
  dictatorVictory: outcome.dictatorVictory,
});
```
  </action>
  <verify>
Run `npx vitest run` -- all existing tests must pass. Grep for callback patterns: `game.animate\(.*\) => \{` should return zero results in combat.ts. The only pattern allowed is `game.animate('type', { data })` with no third argument.
  </verify>
  <done>All 10 animate calls in combat.ts are pure data (no callback argument). All combat tests pass unchanged.</done>
</task>

<task type="auto">
  <name>Task 2: Extract mutations from all 3 animate callbacks in rebel-combat.ts</name>
  <files>src/rules/actions/rebel-combat.ts</files>
  <action>
For each heal animate call, move the callback body to immediately after the `game.animate()` call. These are all `combat-heal` events with complex multi-step mutations (dice tracking, healing, item management, equipment discarding).

**Call 11: combat-heal (medical kit heal action) ~line 811**
Move the entire callback body after animate. This includes:
- Track dice discarded: `game.activeCombat!.healingDiceUsed.set(...)`
- Heal the target: `targetCombatant.health += healAmount; targetMerc.heal(healAmount);`
- Use up healing item: `healingItem.usesRemaining--`
- If exhausted, unequip from slot (accessory or bandolier), put into discard pile
- Game messages for item use

**Call 12: combat-heal (before-attack heal action) ~line 966**
Same pattern as Call 11. Move entire callback body after animate. Note: the `beforeAttackHealingProcessed` set update and `pendingBeforeAttackHealing = undefined` already happen AFTER the animate call (lines 1012-1016), so they stay where they are.

**Call 13: combat-heal (surgeon ability) ~line 1245**
Move callback body after animate:
- Track dice sacrificed: `game.activeCombat!.healingDiceUsed.set(...)`
- Reduce surgeon combat: `surgeonCombatant.combat--`
- Heal target: `targetCombatant.health = Math.min(...); targetMerc.heal(healAmount);`
- Game message

For all three: keep `healingItem` and other local variable references intact. The variables are in closure scope and remain accessible since the mutations now run in the same scope as the animate call.
  </action>
  <verify>
Run `npx vitest run` -- all existing tests must pass. Grep for callback patterns: `game.animate\(.*\) => \{` should return zero results in rebel-combat.ts.
  </verify>
  <done>All 3 animate calls in rebel-combat.ts are pure data (no callback argument). All combat tests pass unchanged.</done>
</task>

</tasks>

<verification>
1. `npx vitest run` -- all tests pass (expect 602+ passing, 0 failures)
2. `grep -n 'game\.animate.*() =>' src/rules/combat.ts src/rules/actions/rebel-combat.ts` -- returns no results
3. `grep -c 'game\.animate(' src/rules/combat.ts` -- returns 10 (unchanged count)
4. `grep -c 'game\.animate(' src/rules/actions/rebel-combat.ts` -- returns 3 (unchanged count)
</verification>

<success_criteria>
- All 13 game.animate() calls across combat.ts and rebel-combat.ts are pure data with no callbacks
- All existing combat tests pass with zero regressions
- No combat mechanics changed -- same damage, same deaths, same healing, same state transitions
- SRV-03 acceptance criteria fully satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/43-combat-event-architecture/43-01-SUMMARY.md`
</output>
