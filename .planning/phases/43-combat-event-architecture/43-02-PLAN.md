---
phase: 43-combat-event-architecture
plan: 02
type: execute
wave: 2
depends_on: ["43-01"]
files_modified:
  - src/rules/combat.ts
autonomous: true

must_haves:
  truths:
    - "Every decision cycle in combat emits a combat-panel event with full combatant snapshots"
    - "Decision context (target selection, hit allocation, wolverine sixes, attack dog, before-attack healing, epinephrine, combat complete) is embedded in the snapshot"
    - "combat-panel snapshot is a complete, self-contained data packet -- no element ref resolution needed"
    - "Existing combat tests still pass -- snapshot emission is additive only"
  artifacts:
    - path: "src/rules/combat.ts"
      provides: "buildCombatPanelSnapshot() and serializeCombatant() helper functions, combat-panel emissions at all decision points"
      contains: "function buildCombatPanelSnapshot"
    - path: "src/rules/combat.ts"
      provides: "serializeCombatant helper"
      contains: "function serializeCombatant"
  key_links:
    - from: "each game.activeCombat = { ... } assignment in executeCombat"
      to: "game.animate('combat-panel', ...)"
      via: "combat-panel emitted after every activeCombat state save"
      pattern: "game\\.animate\\('combat-panel'"
    - from: "buildCombatPanelSnapshot"
      to: "game.activeCombat"
      via: "reads activeCombat to build snapshot"
      pattern: "buildCombatPanelSnapshot\\(game\\)"
    - from: "serializeCombatant"
      to: "Combatant interface"
      via: "maps Combatant fields to plain data"
      pattern: "function serializeCombatant"
---

<objective>
Add combat-panel snapshot events at every decision cycle in combat, with complete combatant data and decision context.

Purpose: SRV-01 and SRV-02 require that every decision cycle emits a `combat-panel` event containing full combatant snapshots (id, name, image, health, maxHealth, type flags, playerColor) for both sides plus casualties, and that decision context (pending target selection, hit allocation, wolverine sixes, attack dog selection, before-attack healing, epinephrine, combat complete) is embedded in the snapshot. This is the data contract that Phase 44's CombatPanel rebuild will consume.

Output: combat.ts with `buildCombatPanelSnapshot()`, `serializeCombatant()` helpers, and `combat-panel` event emissions at all decision points. Zero test regressions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-combat-event-architecture/43-RESEARCH.md
@.planning/phases/43-combat-event-architecture/43-01-SUMMARY.md
@src/rules/combat.ts
@src/rules/combat-types.ts
@src/rules/game.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add serializeCombatant() and buildCombatPanelSnapshot() helper functions</name>
  <files>src/rules/combat.ts</files>
  <action>
Add two helper functions near the top of combat.ts (after imports, before the combat logic functions). These are internal helpers, not exported.

**serializeCombatant(c: Combatant): Record&lt;string, unknown&gt;**
Maps a Combatant to a plain data object with all fields CombatPanel needs. Per SRV-01 and the CombatPanel's `getCombatantDisplay()` function (CombatPanel.vue lines 565-626), include:
```typescript
function serializeCombatant(c: Combatant): Record<string, unknown> {
  return {
    id: c.id,
    name: c.name,
    image: c.image,
    health: c.health,
    maxHealth: c.maxHealth,
    isMerc: !c.isMilitia && !c.isDictator && !c.isAttackDog,
    isMilitia: c.isMilitia,
    isAttackDog: c.isAttackDog,
    isDictator: c.isDictator,
    isDictatorSide: c.isDictatorSide,
    playerColor: c.playerColor,
    combatantId: c.combatantId,
    // Attack dog specific
    attackDogAssignedTo: c.attackDogAssignedTo,
    attackDogTargetName: c.attackDogTargetName,
    attackDogPendingTarget: c.attackDogPendingTarget,
  };
}
```

**buildCombatPanelSnapshot(game: MERCGame): Record&lt;string, unknown&gt;**
Reads `game.activeCombat` and builds the complete snapshot. Per SRV-01 and SRV-02:
```typescript
function buildCombatPanelSnapshot(game: MERCGame): Record<string, unknown> {
  const ac = game.activeCombat!;
  return {
    sectorId: ac.sectorId,
    sectorName: game.getSector(ac.sectorId)?.sectorName,
    round: ac.round,
    rebelCombatants: ac.rebelCombatants.map(c => serializeCombatant(c)),
    dictatorCombatants: ac.dictatorCombatants.map(c => serializeCombatant(c)),
    rebelCasualties: (ac.rebelCasualties ?? []).map(c => serializeCombatant(c)),
    dictatorCasualties: (ac.dictatorCasualties ?? []).map(c => serializeCombatant(c)),
    dogAssignments: ac.dogAssignments,
    combatComplete: ac.combatComplete ?? false,
    // Decision context -- at most one active at a time
    // Include the full decision data so CombatPanel needs no extra lookups
    pendingTargetSelection: ac.pendingTargetSelection ?? null,
    pendingHitAllocation: ac.pendingHitAllocation ?? null,
    pendingWolverineSixes: ac.pendingWolverineSixes ?? null,
    pendingAttackDogSelection: ac.pendingAttackDogSelection ?? null,
    pendingBeforeAttackHealing: ac.pendingBeforeAttackHealing ?? null,
    pendingEpinephrine: ac.pendingEpinephrine ?? null,
  };
}
```

Note: Use `?? null` for decision context fields so the snapshot always has explicit null values instead of undefined (cleaner for UI consumption). The decision data structures are already serializable -- they were designed for storage in activeCombat which gets serialized by BoardSmith.
  </action>
  <verify>
TypeScript compiles without errors. Run `npx vitest run` -- all tests still pass (functions added but not called yet = no behavior change).
  </verify>
  <done>Both helper functions exist in combat.ts, compile cleanly, and no tests regressed.</done>
</task>

<task type="auto">
  <name>Task 2: Emit combat-panel snapshot at all decision cycle points in executeCombat</name>
  <files>src/rules/combat.ts</files>
  <action>
Add `game.animate('combat-panel', buildCombatPanelSnapshot(game))` after every `game.activeCombat = { ... }` assignment in `executeCombat()` and after every point where the combat pauses for a player decision. There are 7 emission points:

**Point 1: Combat start (~line 2395)**
After the initial `game.activeCombat = { ... }` assignment (before the round loop begins):
```typescript
game.activeCombat = { sectorId: ..., ... };
game.animate('combat-panel', buildCombatPanelSnapshot(game));
```
This gives the UI its initial snapshot of all combatants.

**Point 2: Paused for target selection (~line 2472)**
After `game.activeCombat = { ... pendingTargetSelection: ... }`:
```typescript
game.activeCombat = { ... };
// existing syncMilitiaCasualties call
syncMilitiaCasualties(game, sector, rebels, dictator);
game.animate('combat-panel', buildCombatPanelSnapshot(game));
// existing message + return
```
Place the emit AFTER syncMilitiaCasualties so the snapshot reflects militia state.

**Point 3: Paused for hit allocation (~line 2525)**
After `game.activeCombat = { ... }` (pendingHitAllocation is already set in activeCombat by executeCombatRound):
```typescript
game.activeCombat = { ...game.activeCombat!, ... };
syncMilitiaCasualties(game, sector, rebels, dictator);
game.animate('combat-panel', buildCombatPanelSnapshot(game));
```

**Point 4: Paused for before-attack healing (~line 2566)**
After `game.activeCombat = { ...game.activeCombat!, ... }` (pendingBeforeAttackHealing is already set):
```typescript
game.activeCombat = { ...game.activeCombat!, ... };
syncMilitiaCasualties(game, sector, rebels, dictator);
game.animate('combat-panel', buildCombatPanelSnapshot(game));
```

**Point 5: Paused for attack dog selection (~line 2607)**
After `game.activeCombat = { ... pendingAttackDogSelection: ... }`:
```typescript
game.activeCombat = { ... };
syncMilitiaCasualties(game, sector, rebels, dictator);
game.animate('combat-panel', buildCombatPanelSnapshot(game));
```

**Point 6: Paused for retreat/continue (~line 2695)**
After `game.activeCombat = { ... }`:
```typescript
game.activeCombat = { ... };
game.animate('combat-panel', buildCombatPanelSnapshot(game));
combatPending = true;
```

**Point 7: Combat complete (~line 2770)**
After `game.activeCombat = combatEndState` (which has `combatComplete: true`):
```typescript
game.activeCombat = combatEndState;
game.animate('combat-panel', buildCombatPanelSnapshot(game));
game.animate('combat-end', { ... });
```
Emit combat-panel BEFORE combat-end so the UI gets the final snapshot with combatComplete: true before the end animation event.

**NOT emitted in executeCombatRound:** The `pendingHitAllocation`, `pendingBeforeAttackHealing`, and `pendingEpinephrine` set inside `executeCombatRound` get picked up when the round result is handled back in `executeCombat` (Points 3, 4 above). Epinephrine and wolverine sixes are handled through the flow engine's action steps where `pendingEpinephrine`/`pendingWolverineSixes` are already on `game.activeCombat` and the snapshot will naturally include them at the next decision cycle emission.

**Pattern:** Always place `game.animate('combat-panel', buildCombatPanelSnapshot(game))` AFTER `syncMilitiaCasualties` when it exists (so militia counts are accurate), and AFTER any pending state is set on activeCombat (so decision context is included).
  </action>
  <verify>
Run `npx vitest run` -- all existing tests pass (snapshot emission is additive, does not change combat mechanics).
Count combat-panel emissions: `grep -c "game.animate('combat-panel'" src/rules/combat.ts` should return 7.
Verify no snapshot is emitted inside executeCombatRound (only in executeCombat): `grep -n "combat-panel" src/rules/combat.ts` and check line numbers are all in the executeCombat function.
  </verify>
  <done>7 combat-panel snapshot emissions in executeCombat covering: combat start, target selection, hit allocation, before-attack healing, attack dog selection, retreat/continue, and combat complete. All tests pass. Decision context is embedded in each snapshot via buildCombatPanelSnapshot reading activeCombat.</done>
</task>

</tasks>

<verification>
1. `npx vitest run` -- all tests pass (expect 602+ passing, 0 failures)
2. `grep -c "game.animate('combat-panel'" src/rules/combat.ts` -- returns 7
3. `grep -n "buildCombatPanelSnapshot" src/rules/combat.ts` -- shows function definition + 7 call sites
4. `grep -n "serializeCombatant" src/rules/combat.ts` -- shows function definition + usage in buildCombatPanelSnapshot
5. Verify decision context fields in snapshot: `grep -A20 "function buildCombatPanelSnapshot" src/rules/combat.ts` shows pendingTargetSelection, pendingHitAllocation, pendingWolverineSixes, pendingAttackDogSelection, pendingBeforeAttackHealing, pendingEpinephrine, combatComplete
</verification>

<success_criteria>
- combat-panel snapshot emitted at every decision cycle point (7 points)
- Snapshot contains full combatant data: id, name, image, health, maxHealth, isMerc, isMilitia, isAttackDog, isDictator, playerColor, combatantId
- Snapshot contains decision context: all 6 pending decision types + combatComplete flag
- serializeCombatant() provides consistent combatant data shape across all snapshots
- SRV-01 and SRV-02 acceptance criteria fully satisfied
- All existing tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/43-combat-event-architecture/43-02-SUMMARY.md`
</output>
