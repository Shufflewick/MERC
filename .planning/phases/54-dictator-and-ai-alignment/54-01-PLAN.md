---
phase: 54-dictator-and-ai-alignment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/rules/game.ts
  - src/rules/flow.ts
  - src/rules/actions/rebel-movement.ts
  - src/rules/actions/rebel-economy.ts
  - src/rules/actions/rebel-equipment.ts
  - src/rules/actions/rebel-combat.ts
  - tests/dictator-combat-subflow.test.ts
  - tests/ai-rebel-batching.test.ts
autonomous: true

must_haves:
  truths:
    - "Dictator turn triggers combat through the shared combatResolutionFlow sub-flow (not duplicate inline code)"
    - "AI rebel players in a simultaneous step submit one action each before any AI rebel submits a second action"
    - "Human rebel players can submit actions freely regardless of AI batching state"
    - "AI batching resets correctly when the simultaneous step re-enters after a combat barrier"
    - "An AI rebel that ends turn (all MERCs exhausted) does not block the batching round from advancing"
  artifacts:
    - path: "src/rules/game.ts"
      provides: "Rebel action round tracking state and helpers"
      contains: "rebelActionRound"
    - path: "src/rules/flow.ts"
      provides: "Round tracking reset at simultaneous step entry"
      contains: "resetRebelActionRound"
    - path: "tests/dictator-combat-subflow.test.ts"
      provides: "FLOW-05 verification tests"
    - path: "tests/ai-rebel-batching.test.ts"
      provides: "AI-01 batching integration tests"
  key_links:
    - from: "src/rules/actions/rebel-movement.ts"
      to: "src/rules/game.ts"
      via: "action condition checks rebelActionRound"
      pattern: "rebelActionRound"
    - from: "src/rules/flow.ts"
      to: "src/rules/game.ts"
      via: "resetRebelActionRound called before simultaneousActionStep"
      pattern: "resetRebelActionRound"
---

<objective>
Verify FLOW-05 (dictator uses shared combat sub-flow) and implement AI-01 (AI rebel action batching in simultaneous play).

Purpose: FLOW-05 is already implemented (Phase 51 wired combatResolutionFlow into all 3 dictator call sites), but needs verification tests. AI-01 is the real work: AI rebels in simultaneous play must submit actions in coordinated rounds so all AI rebels take their first action before any takes a second.

Output: Verification tests for FLOW-05, game state + action conditions + integration tests for AI-01.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/54-dictator-and-ai-alignment/54-RESEARCH.md
@src/rules/flow.ts
@src/rules/game.ts
@src/rules/actions/rebel-movement.ts
@src/rules/actions/rebel-economy.ts
@src/rules/actions/rebel-equipment.ts
@src/rules/actions/rebel-combat.ts
@tests/combat-barriers.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add rebel action round tracking and gate AI actions</name>
  <files>
    src/rules/game.ts
    src/rules/flow.ts
    src/rules/actions/rebel-movement.ts
    src/rules/actions/rebel-economy.ts
    src/rules/actions/rebel-equipment.ts
    src/rules/actions/rebel-combat.ts
  </files>
  <action>
    **Add round tracking state to MERCGame (game.ts):**

    Add these properties to MERCGame:
    - `rebelActionRound: number = 0` — current round number (0-indexed)
    - `rebelActionsThisRound: Map<number, number> = new Map()` — maps player seat to number of actions taken this round

    Add these methods to MERCGame:
    - `resetRebelActionRound(): void` — sets `rebelActionRound = 0`, clears `rebelActionsThisRound` map. Called at the start of each simultaneousActionStep entry.
    - `recordRebelAction(playerSeat: number): void` — increments the count in `rebelActionsThisRound` for the given seat. Then checks if ALL AI rebels have taken an action this round (or are done/have no actions). If so, increments `rebelActionRound` and resets per-player counts. "Done" means the player's team has no MERCs with actionsRemaining > 0.
    - `canAIRebelAct(playerSeat: number): boolean` — returns true if the AI rebel at this seat has NOT yet taken an action in the current round. Returns true always for non-AI players (humans are never gated). Specifically: if `rebelActionsThisRound.get(playerSeat) ?? 0` is less than or equal to `rebelActionRound`, the player can act. Otherwise they must wait.

    These properties should NOT be serialized to game state (they are ephemeral, only relevant during simultaneous step execution). Use a pattern consistent with how other transient state is handled in MERCGame (like `pendingCombat`, `activeCombat` etc — check if those are serialized or transient).

    **Reset round tracking in flow.ts:**

    In the `rebel-phase` loop (Day 2+), add an `execute()` block BEFORE the `simultaneousActionStep('rebel-actions')` that calls `game.resetRebelActionRound()`. This ensures round tracking starts fresh each time the simultaneous step is entered (including after combat barrier re-entry).

    Do the same for the Day 1 rebel landing simultaneous step if it exists (check flow.ts for the Day 1 rebel phase pattern from Phase 52-02).

    **Record actions in flow.ts:**

    After each action resolves in the simultaneous step, `recordRebelAction` needs to be called. However, we cannot hook into the engine's `resumeSimultaneousAction` directly. Instead, the recording should happen inside the action's `execute` handler. BUT this is invasive — adding `game.recordRebelAction(ctx.player.seat)` to every rebel action's execute is a lot of changes and fragile.

    Better approach: Use the `allDone` callback. After each action, BoardSmith calls `allDone`. We already use `allDone` to check for combat breakout. We can also use it to call `recordRebelAction` for the player who just acted. BUT `allDone` doesn't receive the acting player.

    **Best approach — use action conditions only (no recording needed):**

    Actually, the simplest and most robust approach: instead of tracking actions taken per round, use the game state itself. After each action, a MERC's `actionsRemaining` decreases. The "round" concept maps to: each MERC gets 2 actions, so "round 1" = first action for each player, "round 2" = second action for each player. But players have MULTIPLE MERCs, so this is more nuanced.

    Revised approach — track at the ACTION level, not the MERC level:

    Add to MERCGame:
    - `rebelActionCounts: Map<number, number> = new Map()` — maps player seat to total actions taken this simultaneous step
    - `rebelBatchRound: number = 0` — current batch round (0, 1, 2, ...)

    Method `resetRebelBatching(): void` — clears map, sets round to 0.

    Method `shouldGateAIAction(player: MERCPlayer): boolean`:
    - If `!player.isAI` return false (humans never gated)
    - Get this player's action count: `rebelActionCounts.get(player.seat) ?? 0`
    - If count > rebelBatchRound, return true (player is ahead, must wait)
    - Return false

    Method `recordRebelActionForBatching(player: MERCPlayer): void`:
    - Increment `rebelActionCounts` for `player.seat`
    - Check if all AI rebels have taken at least `rebelBatchRound + 1` actions (or are done)
    - If so, increment `rebelBatchRound`

    **Gate AI actions via conditions on rebel actions (rebel-movement.ts, rebel-economy.ts, rebel-equipment.ts, rebel-combat.ts):**

    Add a condition to EVERY rebel action that participates in the simultaneous step. The condition:
    ```
    'ai batch gate': (ctx) => !game.shouldGateAIAction(ctx.player as MERCPlayer)
    ```

    This must be added to: `move`, `explore`, `train`, `hireMerc`, `reEquip`, `dropEquipment`, `hospital`, `mortar`, `assignToSquad`, `endTurn`, `coordinatedAttack`, `declareMultiPlayerAttack`, `feedbackDiscard`, `squidheadDisarm`, `squidheadArm`, `hagnessDrawType`, `hagnessGiveEquipment`, `armsDealer`, `repairKit`.

    Do NOT add it to dictator actions (they are not in the simultaneous step).

    **Record actions — hook into action execute:**

    The `recordRebelActionForBatching` call needs to happen after each rebel action executes during simultaneous play. The cleanest place is in each action's `.execute()` handler. Add at the END of the execute function for each rebel action listed above:
    ```
    game.recordRebelActionForBatching(ctx.player as MERCPlayer);
    ```

    IMPORTANT: Only call this during rebel simultaneous play, not during dictator turn actions that share the same action definitions (like `move`, `explore`, `train`). Check `ctx.player.isRebel()` before recording. Some actions (move, explore, train, reEquip, etc.) are used by BOTH rebels and dictator. Guard the call:
    ```
    if (ctx.player.isRebel()) {
      game.recordRebelActionForBatching(ctx.player as MERCPlayer);
    }
    ```

    **Edge case — endTurn and exhausted MERCs:**
    When `recordRebelActionForBatching` checks if all AI rebels have caught up, it must treat players whose team has no actionsRemaining > 0 as "caught up" (they can't take more actions, so they shouldn't block the round). Similarly, players marked as done by `playerDone` should not block advancement.
  </action>
  <verify>
    Run `npx vitest run` — all existing tests must pass. The new conditions should not change behavior for existing tests because:
    - Tests with a single rebel player: no AI batching gate applies (only one player, round always advances immediately)
    - Tests with AI dictator: dictator actions don't have the gate
    - The gate only activates for AI rebel players in multi-rebel games
  </verify>
  <done>
    MERCGame has `rebelActionCounts`, `rebelBatchRound`, `resetRebelBatching()`, `shouldGateAIAction()`, `recordRebelActionForBatching()`. All rebel actions have the AI batch gate condition. All rebel action executes call `recordRebelActionForBatching` (guarded by `isRebel()`). `flow.ts` calls `resetRebelBatching()` before each simultaneous step entry. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write FLOW-05 verification and AI-01 batching integration tests</name>
  <files>
    tests/dictator-combat-subflow.test.ts
    tests/ai-rebel-batching.test.ts
  </files>
  <action>
    **FLOW-05 verification tests (tests/dictator-combat-subflow.test.ts):**

    Write tests that verify the dictator turn uses `combatResolutionFlow` at all 3 call sites. Use the GameRunner pattern from `tests/combat-barriers.test.ts`.

    Test 1: "dictator tactics card combat uses shared sub-flow"
    - Set up a game, advance to dictator turn
    - Play a tactics card that triggers combat (e.g., Fodder)
    - Verify combat resolves through the standard combat resolution flow (check that activeCombat is set and resolves)
    - The key verification: the flow steps after tactics play include combat resolution steps (healing, target selection, etc.)

    Test 2: "dictator MERC move combat uses shared sub-flow"
    - Set up a game with dictator MERCs that can move into a sector with rebels
    - Move dictator MERC into rebel-occupied sector
    - Verify combat triggers and resolves through combat resolution flow

    NOTE: These tests may be complex to set up due to needing specific board states. If direct testing of the dictator flow path is too complex (requires driving through the full Day 1 + Day 2 flow), an acceptable alternative is a code-level assertion: write a test that imports flow.ts and inspects the flow definition to verify `combatResolutionFlow` is called at the three expected locations. Or use a simpler approach: grep/read flow.ts in the test and assert the three call sites exist. This is a verification-only test — the behavior is already tested by existing tests.

    Simpler approach: Write a single test that reads flow.ts source and asserts the three dictator combat sub-flow call sites exist:
    ```typescript
    import { readFileSync } from 'fs';

    test('dictator turn uses combatResolutionFlow at all 3 sites', () => {
      const flowSource = readFileSync('src/rules/flow.ts', 'utf-8');
      // Tactics combat
      expect(flowSource).toContain("combatResolutionFlow(game, 'tactics-combat')");
      // Dictator MERC combat
      expect(flowSource).toContain("combatResolutionFlow(game, 'dictator-combat')");
      // Kim militia combat
      expect(flowSource).toContain("combatResolutionFlow(game, 'kim-militia-combat')");
    });
    ```

    **AI-01 batching integration tests (tests/ai-rebel-batching.test.ts):**

    Use the GameRunner pattern from `tests/combat-barriers.test.ts`. Set up a 3-player game (1 dictator + 2 AI rebels).

    Test 1: "AI rebels batch actions — all first actions before any second actions"
    - Create a game with 2 AI rebel players
    - Advance to Day 2 rebel simultaneous step
    - Drive the flow: get available actions for first AI rebel, submit one action
    - After first AI rebel acts, verify second AI rebel has available actions (round should NOT have advanced yet if only one AI acted)
    - Submit action for second AI rebel
    - Now verify first AI rebel has available actions again (round should have advanced)
    - This proves round-robin batching

    Test 2: "human rebel can act freely regardless of AI batch state"
    - Create a game with 1 human rebel + 1 AI rebel
    - Advance to rebel simultaneous step
    - Human submits an action
    - Human submits ANOTHER action immediately (should not be gated)
    - AI rebel should also be able to act (human actions don't affect AI round tracking? Actually they do since `recordRebelActionForBatching` is called for all rebels. BUT `shouldGateAIAction` only gates AI players. Hmm — we need to think about this.)

    IMPORTANT DESIGN CLARIFICATION: `recordRebelActionForBatching` should only record for AI players. If human actions are recorded, the round tracking gets confused because humans can submit multiple actions quickly. Only track AI rebel action counts. Update the guard:
    ```
    if (ctx.player.isRebel() && ctx.player.isAI) {
      game.recordRebelActionForBatching(ctx.player as MERCPlayer);
    }
    ```
    And `shouldGateAIAction` already gates only AI players. This means: humans never gated, humans don't affect AI round tracking, AI rebels batch among themselves.

    Wait — this changes Task 1. The `recordRebelActionForBatching` guard should be `isRebel() && isAI`, not just `isRebel()`. Update the execute hooks in Task 1 accordingly.

    Test 3: "AI rebel that ends turn does not block batch round advancement"
    - 2 AI rebels, one has all MERCs exhausted (actionsRemaining = 0)
    - The other AI rebel should be able to take multiple actions without waiting
    - Verify the exhausted rebel is treated as "caught up" in every round

    Test 4: "batching resets after combat barrier re-entry"
    - 2 AI rebels in simultaneous step
    - Both take one action (round advances)
    - Combat triggers, simultaneous step exits via allDone
    - After combat resolves, simultaneous step re-enters
    - Verify batch round is reset to 0 (both AI rebels can act again from round 0)

    Use the multi-seed iteration pattern from combat-barriers.test.ts if needed to find viable game states. Use the `getCurrentAction` and `isRebelActionsStep` helpers.

    For test setup with AI rebel players, configure the GameRunner with player configs that set `isAI: true` for rebel players. Check how `MERCGame.addRebelPlayer` uses `playerConfig.isAI` (game.ts lines 889-891).
  </action>
  <verify>
    Run `npx vitest run tests/dictator-combat-subflow.test.ts` — all FLOW-05 tests pass.
    Run `npx vitest run tests/ai-rebel-batching.test.ts` — all AI-01 tests pass.
    Run `npx vitest run` — full suite passes (no regressions).
  </verify>
  <done>
    FLOW-05 is verified by test asserting all 3 combatResolutionFlow call sites in the dictator turn. AI-01 is verified by integration tests proving: (1) AI rebels batch actions in rounds, (2) humans act freely, (3) exhausted AI rebels don't block rounds, (4) batching resets after combat barrier re-entry.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run` — full test suite passes with no regressions
2. `tests/dictator-combat-subflow.test.ts` verifies FLOW-05 (3 dictator combat sub-flow call sites)
3. `tests/ai-rebel-batching.test.ts` verifies AI-01 (batching behavior, human freedom, exhausted player handling, barrier reset)
4. No existing test behavior changes (the AI batch gate only activates for AI rebel players in multi-rebel simultaneous steps)
</verification>

<success_criteria>
- FLOW-05: All 3 dictator combatResolutionFlow call sites verified by test
- AI-01: AI rebels provably submit actions in batched rounds (first actions for all, then second actions for all)
- AI-01: Human rebels are never gated by AI batching
- AI-01: Batching handles edge cases (exhausted players, combat barrier re-entry)
- All existing tests pass without modification
</success_criteria>

<output>
After completion, create `.planning/phases/54-dictator-and-ai-alignment/54-01-SUMMARY.md`
</output>
