---
phase: 54-dictator-and-ai-alignment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/rules/game.ts
  - src/rules/flow.ts
  - src/rules/actions/rebel-movement.ts
  - src/rules/actions/rebel-economy.ts
  - src/rules/actions/rebel-equipment.ts
  - src/rules/actions/rebel-combat.ts
  - tests/dictator-combat-subflow.test.ts
  - tests/ai-rebel-batching.test.ts
autonomous: true

must_haves:
  truths:
    - "Dictator turn triggers combat through the shared combatResolutionFlow sub-flow (not duplicate inline code)"
    - "AI rebel players in a simultaneous step submit one action each before any AI rebel submits a second action"
    - "Human rebel players can submit actions freely regardless of AI batching state"
    - "AI batching resets correctly when the simultaneous step re-enters after a combat barrier"
    - "An AI rebel that ends turn (all MERCs exhausted) does not block the batching round from advancing"
  artifacts:
    - path: "src/rules/game.ts"
      provides: "Rebel action round tracking state and helpers"
      contains: "rebelBatchRound"
    - path: "src/rules/flow.ts"
      provides: "Round tracking reset at simultaneous step entry"
      contains: "resetRebelBatching"
    - path: "tests/dictator-combat-subflow.test.ts"
      provides: "FLOW-05 verification tests"
    - path: "tests/ai-rebel-batching.test.ts"
      provides: "AI-01 batching integration tests"
  key_links:
    - from: "src/rules/actions/rebel-*.ts"
      to: "src/rules/game.ts"
      via: "action condition checks shouldGateAIAction"
      pattern: "shouldGateAIAction"
    - from: "src/rules/actions/rebel-*.ts"
      to: "src/rules/game.ts"
      via: "action execute calls recordRebelActionForBatching"
      pattern: "recordRebelActionForBatching"
    - from: "src/rules/flow.ts"
      to: "src/rules/game.ts"
      via: "resetRebelBatching called before simultaneousActionStep"
      pattern: "resetRebelBatching"
---

<objective>
Verify FLOW-05 (dictator uses shared combat sub-flow) and implement AI-01 (AI rebel action batching in simultaneous play).

Purpose: FLOW-05 is already implemented (Phase 51 wired combatResolutionFlow into all 3 dictator call sites), but needs verification tests. AI-01 is the real work: AI rebels in simultaneous play must submit actions in coordinated rounds so all AI rebels take their first action before any takes a second.

Output: Verification tests for FLOW-05, game state + action conditions + integration tests for AI-01.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/54-dictator-and-ai-alignment/54-RESEARCH.md
@src/rules/flow.ts
@src/rules/game.ts
@src/rules/actions/rebel-movement.ts
@src/rules/actions/rebel-economy.ts
@src/rules/actions/rebel-equipment.ts
@src/rules/actions/rebel-combat.ts
@tests/combat-barriers.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AI rebel batching state and methods to MERCGame, reset in flow.ts</name>
  <files>
    src/rules/game.ts
    src/rules/flow.ts
  </files>
  <action>
    **Design: AI rebel action batching**

    AI rebels in simultaneous play must take actions in coordinated rounds. In each round, every AI rebel submits one action (or is skipped if exhausted/done). Only after all AI rebels have acted does the next round begin. Human rebels are never gated and do not participate in round tracking.

    **Add batching state to MERCGame (game.ts):**

    Add these as PRIVATE properties (private fields are not serialized by BoardSmith, which is correct -- batching state is ephemeral to the simultaneous step and must not persist to clients):

    - `private _rebelActionCounts: Map<number, number> = new Map()` -- maps AI rebel player seat to total actions taken this simultaneous step
    - `private _rebelBatchRound: number = 0` -- current batch round (0, 1, 2, ...)

    **Add these methods to MERCGame:**

    `resetRebelBatching(): void`
    - Sets `_rebelBatchRound = 0`, clears `_rebelActionCounts` map.
    - Called at the start of each simultaneousActionStep entry (including re-entry after combat barriers).

    `shouldGateAIAction(player: MERCPlayer): boolean`
    - If `!player.isAI` return false (humans are never gated).
    - If `!player.isRebel()` return false (dictator actions are never gated).
    - Get this player's action count: `this._rebelActionCounts.get(player.seat) ?? 0`
    - If count > `this._rebelBatchRound`, return true (player is ahead of the current round, must wait).
    - Return false.

    `recordRebelActionForBatching(player: MERCPlayer): void`
    - Increment `_rebelActionCounts` for `player.seat`.
    - Check if all AI rebels have taken at least `_rebelBatchRound + 1` actions, OR are "done" (no MERCs with actionsRemaining > 0, or player marked done via playerDone). An exhausted/done AI rebel should not block round advancement.
    - If all AI rebels are caught up or done, increment `_rebelBatchRound`.

    To find "all AI rebels": iterate `this.rebelPlayers` and filter by `.isAI`.

    **Reset batching in flow.ts:**

    In the `rebel-phase` loop (Day 2+), add an `execute()` block BEFORE the `simultaneousActionStep('rebel-actions')` that calls `game.resetRebelBatching()`. This ensures round tracking starts fresh each time the simultaneous step is entered (including after combat barrier re-entry).

    Do the same for the Day 1 rebel landing simultaneous step if it exists (check flow.ts for the Day 1 rebel phase pattern from Phase 52-02).
  </action>
  <verify>
    Run `npx vitest run` -- all existing tests must pass. The new state and methods add no behavior yet (action conditions and execute hooks are wired in Task 2).
  </verify>
  <done>
    MERCGame has private `_rebelActionCounts` and `_rebelBatchRound` properties with `resetRebelBatching()`, `shouldGateAIAction()`, and `recordRebelActionForBatching()` methods. `flow.ts` calls `resetRebelBatching()` before each simultaneous step entry (Day 1 and Day 2+). All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire AI batch gate condition and recording hook into all rebel actions</name>
  <files>
    src/rules/actions/rebel-movement.ts
    src/rules/actions/rebel-economy.ts
    src/rules/actions/rebel-equipment.ts
    src/rules/actions/rebel-combat.ts
  </files>
  <action>
    **Add AI batch gate condition to every rebel action that participates in the simultaneous step.**

    The condition to add to each action's conditions object:

    ```typescript
    'ai batch gate': (ctx) => !game.shouldGateAIAction(ctx.player as MERCPlayer)
    ```

    This returns false (blocking the action) when an AI rebel is ahead of the current batch round.

    **Checklist of actions to update (add BOTH the condition AND the execute hook):**

    rebel-movement.ts:
    - [ ] `move`
    - [ ] `explore`

    rebel-economy.ts:
    - [ ] `train`
    - [ ] `hireMerc`
    - [ ] `hospital`
    - [ ] `armsDealer`

    rebel-equipment.ts:
    - [ ] `reEquip`
    - [ ] `dropEquipment`
    - [ ] `repairKit`

    rebel-combat.ts:
    - [ ] `mortar`
    - [ ] `assignToSquad`
    - [ ] `endTurn`
    - [ ] `coordinatedAttack`
    - [ ] `declareMultiPlayerAttack`
    - [ ] `feedbackDiscard`
    - [ ] `squidheadDisarm`
    - [ ] `squidheadArm`
    - [ ] `hagnessDrawType`
    - [ ] `hagnessGiveEquipment`

    Do NOT add to dictator actions (they are not in the simultaneous step).

    **Add recording hook to each action's execute handler.**

    At the END of each action's `.execute()` function listed above, add:

    ```typescript
    if (ctx.player.isRebel() && ctx.player.isAI) {
      game.recordRebelActionForBatching(ctx.player as MERCPlayer);
    }
    ```

    The guard `isRebel() && isAI` is critical:
    - `isRebel()` is needed because some actions (move, explore, train, reEquip, etc.) are shared with dictator MERCs. Without it, dictator actions would corrupt the batch state.
    - `isAI` is needed because human rebel actions must not be recorded. Humans can submit actions freely and at any pace. If human actions were tracked, the round accounting would break (human could submit 5 actions rapidly, advancing the round counter and desynchronizing AI tracking).

    Only AI rebel actions participate in batch round tracking. Only AI rebel actions are gated by the batch condition.
  </action>
  <verify>
    Run `npx vitest run` -- all existing tests must pass. The batch gate only activates for AI rebel players in multi-rebel simultaneous steps. Existing tests use single-rebel or non-AI configurations, so the gate condition should always return false (not gated) for them.
  </verify>
  <done>
    All ~20 rebel actions listed above have both: (1) the `'ai batch gate'` condition calling `shouldGateAIAction`, and (2) the `recordRebelActionForBatching` call in execute guarded by `isRebel() && isAI`. All existing tests pass without modification.
  </done>
</task>

<task type="auto">
  <name>Task 3: Write FLOW-05 verification and AI-01 batching integration tests</name>
  <files>
    tests/dictator-combat-subflow.test.ts
    tests/ai-rebel-batching.test.ts
  </files>
  <action>
    **FLOW-05 verification tests (tests/dictator-combat-subflow.test.ts):**

    Write a single structural verification test that confirms the dictator turn uses `combatResolutionFlow` at all 3 call sites. This is a verification-only test -- the behavior is already tested by existing tests.

    ```typescript
    import { readFileSync } from 'fs';

    test('dictator turn uses combatResolutionFlow at all 3 sites', () => {
      const flowSource = readFileSync('src/rules/flow.ts', 'utf-8');
      // Tactics combat
      expect(flowSource).toContain("combatResolutionFlow(game, 'tactics-combat')");
      // Dictator MERC combat
      expect(flowSource).toContain("combatResolutionFlow(game, 'dictator-combat')");
      // Kim militia combat
      expect(flowSource).toContain("combatResolutionFlow(game, 'kim-militia-combat')");
    });
    ```

    **AI-01 batching integration tests (tests/ai-rebel-batching.test.ts):**

    Use the GameRunner pattern from `tests/combat-barriers.test.ts`. Set up a 3-player game (1 dictator + 2 AI rebels).

    Test 1: "AI rebels batch actions -- all first actions before any second actions"
    - Create a game with 2 AI rebel players
    - Advance to Day 2 rebel simultaneous step
    - Drive the flow: get available actions for first AI rebel, submit one action
    - After first AI rebel acts, verify second AI rebel has available actions (round should NOT have advanced yet if only one AI acted)
    - Submit action for second AI rebel
    - Now verify first AI rebel has available actions again (round should have advanced)
    - This proves round-robin batching

    Test 2: "human rebel can act freely regardless of AI batch state"
    - Create a game with 1 human rebel + 1 AI rebel
    - Advance to rebel simultaneous step
    - Human submits an action, then ANOTHER action immediately (should not be gated)
    - AI rebel should also be able to act (human actions do not affect AI round tracking since the recording guard is `isRebel() && isAI`)

    Test 3: "AI rebel that ends turn does not block batch round advancement"
    - 2 AI rebels, one has all MERCs exhausted (actionsRemaining = 0)
    - The other AI rebel should be able to take multiple actions without waiting
    - Verify the exhausted rebel is treated as "caught up" in every round

    Test 4: "batching resets after combat barrier re-entry"
    - 2 AI rebels in simultaneous step
    - Both take one action (round advances)
    - Combat triggers, simultaneous step exits via allDone
    - After combat resolves, simultaneous step re-enters
    - Verify batch round is reset to 0 (both AI rebels can act again from round 0)

    Use the multi-seed iteration pattern from combat-barriers.test.ts if needed to find viable game states. Use the `getCurrentAction` and `isRebelActionsStep` helpers.

    For test setup with AI rebel players, configure the GameRunner with player configs that set `isAI: true` for rebel players. Check how `MERCGame.addRebelPlayer` uses `playerConfig.isAI` (game.ts).
  </action>
  <verify>
    Run `npx vitest run tests/dictator-combat-subflow.test.ts` -- all FLOW-05 tests pass.
    Run `npx vitest run tests/ai-rebel-batching.test.ts` -- all AI-01 tests pass.
    Run `npx vitest run` -- full suite passes (no regressions).
  </verify>
  <done>
    FLOW-05 is verified by test asserting all 3 combatResolutionFlow call sites in the dictator turn. AI-01 is verified by integration tests proving: (1) AI rebels batch actions in rounds, (2) humans act freely, (3) exhausted AI rebels don't block rounds, (4) batching resets after combat barrier re-entry.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run` -- full test suite passes with no regressions
2. `tests/dictator-combat-subflow.test.ts` verifies FLOW-05 (3 dictator combat sub-flow call sites)
3. `tests/ai-rebel-batching.test.ts` verifies AI-01 (batching behavior, human freedom, exhausted player handling, barrier reset)
4. No existing test behavior changes (the AI batch gate only activates for AI rebel players in multi-rebel simultaneous steps)
</verification>

<success_criteria>
- FLOW-05: All 3 dictator combatResolutionFlow call sites verified by test
- AI-01: AI rebels provably submit actions in batched rounds (first actions for all, then second actions for all)
- AI-01: Human rebels are never gated by AI batching
- AI-01: Batching handles edge cases (exhausted players, combat barrier re-entry)
- All existing tests pass without modification
</success_criteria>

<output>
After completion, create `.planning/phases/54-dictator-and-ai-alignment/54-01-SUMMARY.md`
</output>
