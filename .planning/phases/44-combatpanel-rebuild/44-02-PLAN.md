---
phase: 44-combatpanel-rebuild
plan: 02
type: execute
wave: 2
depends_on: ["44-01"]
files_modified:
  - src/ui/components/CombatPanel.vue
autonomous: true

must_haves:
  truths:
    - "All decision prompts (target selection, hit allocation, wolverine sixes, attack dog, before-attack healing) read from the snapshot's decision context fields, not from activeCombat prop"
    - "Panel opens when first combat-panel event arrives and closes after combat-end animation finishes"
    - "combat-finished event is emitted to GameTable when combat-end handler completes"
    - "Zero references to panelState, CombatPanelState, computeNextState, transitionState, sawCombatEndEvent in CombatPanel.vue"
    - "Fast-forward still works (isFastForward, getTiming unchanged)"
  artifacts:
    - path: "src/ui/components/CombatPanel.vue"
      provides: "Snapshot-driven decisions + event-driven lifecycle"
      contains: "combatSnapshot"
  key_links:
    - from: "combat-end handler"
      to: "emit('combat-finished')"
      via: "Handler clears snapshot and emits after sleep"
      pattern: "combat-end.*combat-finished"
    - from: "decision computed properties"
      to: "combatSnapshot"
      via: "isSelectingTargets reads combatSnapshot.pendingTargetSelection"
      pattern: "combatSnapshot.*pending"
    - from: "template decision panels"
      to: "combatSnapshot"
      via: "v-if reads snapshot decision context"
      pattern: "combatSnapshot.*pending"
---

<objective>
Rewire all decision prompts to read from snapshot and replace the state machine with event-driven lifecycle.

Purpose: This completes UI-02 (decision prompts from snapshot), UI-03 (simplified lifecycle), DELETE-03 (state machine removal). After this plan, CombatPanel is a self-contained animation player with zero references to the old theatre-view-based state machine or activeCombat-based decision reading.

Output: CombatPanel.vue with all decision prompts reading from combatSnapshot, state machine fully removed, and panel lifecycle driven by snapshot presence + combat-end handler.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/44-combatpanel-rebuild/44-RESEARCH.md
@.planning/phases/44-combatpanel-rebuild/44-01-SUMMARY.md

Key reference: The snapshot decision context fields (from RESEARCH.md):
- pendingTargetSelection: { attackerId, attackerName, validTargets, maxTargets } | null
- pendingHitAllocation: PendingHitAllocation | null
- pendingWolverineSixes: { attackerId, attackerName, sixCount, bonusTargets } | null
- pendingAttackDogSelection: { attackerId, attackerName, validTargets } | null
- pendingBeforeAttackHealing: { attackerId, attackerName, availableHealers, damagedAllies } | null
- combatComplete: boolean
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewire decision prompts and interactive functions to snapshot</name>
  <files>src/ui/components/CombatPanel.vue</files>
  <action>
  Replace all `props.activeCombat?.pendingXxx` reads with `combatSnapshot.value?.pendingXxx` reads in both script and template.

  **Script computed properties -- replace these:**

  `isSelectingTargets` (currently reads `props.activeCombat?.pendingTargetSelection`):
  ```typescript
  const isSelectingTargets = computed(() => {
    return !!combatSnapshot.value?.pendingTargetSelection && props.isMyTurn;
  });
  ```

  `maxTargets` (currently reads `props.activeCombat?.pendingTargetSelection?.maxTargets`):
  ```typescript
  const maxTargets = computed(() => {
    const pending = combatSnapshot.value?.pendingTargetSelection as any;
    return pending?.maxTargets ?? 0;
  });
  ```

  `isAllocating` (currently reads `props.activeCombat?.pendingHitAllocation`):
  ```typescript
  const isAllocating = computed(() => {
    return !!combatSnapshot.value?.pendingHitAllocation && props.isMyTurn;
  });
  ```

  `isAllocatingWolverineSixes` (currently reads `props.activeCombat?.pendingWolverineSixes`):
  ```typescript
  const isAllocatingWolverineSixes = computed(() => {
    return !!combatSnapshot.value?.pendingWolverineSixes && props.isMyTurn;
  });
  ```

  `isAssigningAttackDog` (currently reads `props.activeCombat?.pendingAttackDogSelection`):
  ```typescript
  const isAssigningAttackDog = computed(() => {
    return !!combatSnapshot.value?.pendingAttackDogSelection && props.isMyTurn;
  });
  ```

  `isHealingBeforeAttack` (currently reads `props.activeCombat?.pendingBeforeAttackHealing`):
  ```typescript
  const isHealingBeforeAttack = computed(() => {
    return !!combatSnapshot.value?.pendingBeforeAttackHealing && props.isMyTurn;
  });
  ```

  **Script functions -- replace activeCombat reads:**

  `findCombatantIdByName()` -- replace `props.activeCombat` reads with snapshot reads:
  ```typescript
  function findCombatantIdByName(name: string): string | null {
    if (!name || !combatSnapshot.value) return null;
    const lowerName = name.toLowerCase();
    const snapshot = combatSnapshot.value;
    const allCombatants = [
      ...((snapshot.rebelCombatants as any[]) || []),
      ...((snapshot.dictatorCombatants as any[]) || []),
      ...((snapshot.rebelCasualties as any[]) || []),
      ...((snapshot.dictatorCasualties as any[]) || []),
    ];
    for (const c of allCombatants) {
      if (!c) continue;
      const cName = (String(c.name ?? '')).toLowerCase();
      if (cName === lowerName || cName.includes(lowerName) || lowerName.includes(cName)) {
        return String(c.id ?? '') || null;
      }
    }
    return null;
  }
  ```
  This removes the resolveCombatant/getAttr/getCombatantId calls -- snapshot combatants have plain `name` and `id` fields.

  `isValidTarget()` -- replace `props.activeCombat?.pending*` reads with snapshot reads:
  ```typescript
  function isValidTarget(targetId: string): boolean {
    const normalized = normalizeId(targetId);
    if (!normalized) return false;
    const snapshot = combatSnapshot.value;
    if (!snapshot) return false;
    if (isSelectingTargets.value) {
      const pending = snapshot.pendingTargetSelection as any;
      return pending?.validTargets?.some((t: any) => normalizeId(t.id) === normalized) ?? false;
    }
    if (isAllocatingWolverineSixes.value) {
      const pending = snapshot.pendingWolverineSixes as any;
      return pending?.bonusTargets?.some((t: any) => normalizeId(t.id) === normalized) ?? false;
    }
    const pending = snapshot.pendingHitAllocation as any;
    return pending?.validTargets?.some((t: any) => normalizeId(t.id) === normalized) ?? false;
  }
  ```

  `selectTarget()` -- replace `props.activeCombat?.pendingTargetSelection?.validTargets` and `props.activeCombat?.pendingHitAllocation?.validTargets` reads with snapshot reads:
  - `props.activeCombat?.pendingTargetSelection?.validTargets` becomes `(combatSnapshot.value?.pendingTargetSelection as any)?.validTargets`
  - `props.activeCombat?.pendingHitAllocation?.validTargets` becomes `(combatSnapshot.value?.pendingHitAllocation as any)?.validTargets`

  `addHitToTarget()` -- same replacement: `props.activeCombat?.pendingHitAllocation?.validTargets` becomes `(combatSnapshot.value?.pendingHitAllocation as any)?.validTargets`

  **Template -- replace activeCombat reads with snapshot reads:**

  Header section (line 896): `displayCombat?.round` already reads from snapshot after Plan 01's displayCombat change. No change needed.

  HitAllocationPanel (line 986-993):
  - `v-if="activeCombat?.pendingHitAllocation && !isAnimating"` becomes `v-if="combatSnapshot?.pendingHitAllocation && !isAnimating"`
  - `:pending-allocation="activeCombat.pendingHitAllocation"` becomes `:pending-allocation="(combatSnapshot?.pendingHitAllocation as any)"`
  Note: If vue-tsc complains about the `as any` in template, use a computed property instead.

  Wolverine sixes section (lines 1046-1054):
  - `v-if="activeCombat?.pendingWolverineSixes && !isAnimating"` becomes `v-if="combatSnapshot?.pendingWolverineSixes && !isAnimating"`
  - `activeCombat.pendingWolverineSixes.attackerName` becomes `(combatSnapshot?.pendingWolverineSixes as any)?.attackerName`
  - `activeCombat.pendingWolverineSixes.sixCount` becomes `(combatSnapshot?.pendingWolverineSixes as any)?.sixCount`

  AttackDogAssignmentPanel (lines 1057-1062):
  - `:attacker-name` reads `activeCombat?.pendingAttackDogSelection?.attackerName` -- change to `(combatSnapshot?.pendingAttackDogSelection as any)?.attackerName ?? ''`
  - `:valid-targets` reads `activeCombat?.pendingAttackDogSelection?.validTargets` -- change to `(combatSnapshot?.pendingAttackDogSelection as any)?.validTargets ?? []`

  Before-attack healing section (lines 1065-1096):
  - All `activeCombat?.pendingBeforeAttackHealing` reads become `(combatSnapshot?.pendingBeforeAttackHealing as any)`
  - `activeCombat?.pendingBeforeAttackHealing?.attackerName` becomes `(combatSnapshot?.pendingBeforeAttackHealing as any)?.attackerName`
  - `activeCombat?.pendingBeforeAttackHealing?.availableHealers` becomes `(combatSnapshot?.pendingBeforeAttackHealing as any)?.availableHealers`
  - `activeCombat?.pendingBeforeAttackHealing?.damagedAllies` becomes `(combatSnapshot?.pendingBeforeAttackHealing as any)?.damagedAllies`

  TargetSelectionPanel (lines 1099-1105):
  - `:attacker-name="activeCombat?.pendingTargetSelection?.attackerName ?? ''"` becomes `:attacker-name="(combatSnapshot?.pendingTargetSelection as any)?.attackerName ?? ''"`

  CombatPanelCombatant `:is-attacking` prop (line 918):
  - `activeCombat?.pendingHitAllocation?.attackerId` becomes `(combatSnapshot?.pendingHitAllocation as any)?.attackerId`

  **Replace the pendingTargetSelection watcher (line 813-815):**
  Currently watches `props.activeCombat?.pendingTargetSelection`. Change to watch snapshot:
  ```typescript
  watch(() => combatSnapshot.value?.pendingTargetSelection, () => {
    selectedTargets.value.clear();
  }, { immediate: true });
  ```

  **IMPORTANT template pattern:** If `as any` in templates causes vue-tsc issues, create computed helpers instead:
  ```typescript
  const snapshotHitAllocation = computed(() => combatSnapshot.value?.pendingHitAllocation as PendingHitAllocation | null);
  const snapshotTargetSelection = computed(() => combatSnapshot.value?.pendingTargetSelection as any);
  const snapshotWolverineSixes = computed(() => combatSnapshot.value?.pendingWolverineSixes as any);
  const snapshotAttackDogSelection = computed(() => combatSnapshot.value?.pendingAttackDogSelection as any);
  const snapshotBeforeAttackHealing = computed(() => combatSnapshot.value?.pendingBeforeAttackHealing as any);
  ```
  Then use these in templates: `v-if="snapshotHitAllocation && !isAnimating"`, `:pending-allocation="snapshotHitAllocation"`, etc. This is cleaner than repeated `as any` in templates.
  </action>
  <verify>
  - `grep -n 'props\.activeCombat\?\.pending' src/ui/components/CombatPanel.vue` returns zero matches -- all pending decision reads come from snapshot
  - `grep -n 'activeCombat\?\.pending' src/ui/components/CombatPanel.vue` returns zero matches in template section
  - `grep -n 'combatSnapshot' src/ui/components/CombatPanel.vue` returns matches in all decision computed properties and template
  - `npx vue-tsc --noEmit` -- no new type errors
  </verify>
  <done>
  All 5 decision prompts (target selection, hit allocation, wolverine sixes, attack dog, before-attack healing) read from combatSnapshot decision context fields. Interactive functions (selectTarget, isValidTarget, findCombatantIdByName) read from snapshot. Template bindings for decision panels use snapshot data.
  </done>
</task>

<task type="auto">
  <name>Task 2: Remove state machine, add event-driven lifecycle</name>
  <files>src/ui/components/CombatPanel.vue</files>
  <action>
  **Modify the combat-end handler** (currently lines 278-282) to emit `combat-finished` and clear the snapshot:
  ```typescript
  animationEvents.registerHandler('combat-end', async (event) => {
    currentEvent.value = mapEventToDisplayState(event);
    await sleep(getTiming('combat-end'));
    // Close panel and signal GameTable
    combatSnapshot.value = null;
    healthOverrides.value.clear();
    healingCombatants.value.clear();
    resetAnimations();
    emit('combat-finished');
  });
  ```
  This replaces the state machine's COMPLETE entry action. The combat-end handler is now the sole path to `combat-finished`.

  CRITICAL: Remove `sawCombatEndEvent.value = true;` from this handler (line 280). The sawCombatEndEvent ref is about to be deleted.

  **Delete the entire state machine section (lines 723-810):**
  Remove ALL of the following:
  - `type CombatPanelState = 'IDLE' | 'ANIMATING' | 'WAITING_FOR_INPUT' | 'COMPLETE';`
  - `const panelState = ref<CombatPanelState>('IDLE');`
  - `const sawCombatEndEvent = ref(false);`
  - `function computeNextState(): CombatPanelState { ... }` (entire function)
  - `function transitionState() { ... }` (entire function)
  - The watcher on `[isAnimating, pendingCount]` that calls `transitionState()` (lines 785-787)
  - The watcher on `props.activeCombat?.combatComplete` that calls `transitionState()` (lines 790-792)
  - The watcher on `props.activeCombat` (null check) that calls `transitionState()` (lines 795-800)
  - The watcher on `props.activeCombat?.sectorId` that resets `panelState` and `sawCombatEndEvent` (lines 803-810)

  **Clean up the sectorId watcher removal:** The watcher on lines 803-810 also resets `healingCombatants` and calls `resetForNewCombat`. This reset is already handled by the watcher on `props.activeCombat` (new vs old) that was kept in Plan 01. Make sure the activeCombat watcher covers the same reset:
  ```typescript
  watch(() => props.activeCombat, (newCombat, oldCombat) => {
    if (newCombat && !oldCombat) {
      resetAnimations();
      healingCombatants.value.clear();
      combatSnapshot.value = null;
    }
  }, { immediate: true });
  ```
  This already exists from Plan 01. The sectorId watcher can be safely removed.

  **Remove resetForNewCombat function (lines 328-330):**
  It just calls `resetAnimations()`. Replace any remaining call to `resetForNewCombat()` with `resetAnimations()` directly. Check:
  - The activeCombat watcher already calls `resetAnimations()` directly
  - `onUnmounted` calls `resetForNewCombat()` -- change to `resetAnimations()`

  **Verify remaining activeCombat prop usage after all deletions:**
  After this task, `props.activeCombat` should ONLY be referenced in:
  1. The `watch(() => props.activeCombat, ...)` that resets state when combat starts (mount trigger watcher)
  2. Possibly nowhere else -- scan and confirm

  If `props.activeCombat` is still referenced anywhere for rendering or decision data, that is a bug -- fix it.

  **Verify no remaining getCombatantId calls that depend on element refs:**
  After Plan 01's getCombatantDisplay rewrite and this task's findCombatantIdByName rewrite, `getCombatantId()` may be unused or only used in the currentEvent watcher. If it is only used in the currentEvent watcher, that watcher uses `findCombatantId(event.targetName)` which calls `findCombatantIdByName` -- which no longer calls `getCombatantId`. So `getCombatantId` may be fully unused. If so, delete it. Also check if `normalizeId` is still used; keep it if any code still calls it.

  **Fast-forward is untouched:** `isFastForward`, `getTiming`, `fastForward()` remain exactly as-is.
  </action>
  <verify>
  - `grep -n 'panelState\|CombatPanelState\|computeNextState\|transitionState\|sawCombatEndEvent' src/ui/components/CombatPanel.vue` returns zero matches
  - `grep -n 'displayHealth\|initializeDisplayHealth' src/ui/components/CombatPanel.vue` returns zero matches (confirm Plan 01 deletions still hold)
  - `grep -n 'resetForNewCombat' src/ui/components/CombatPanel.vue` returns zero matches
  - `grep -c 'props\.activeCombat' src/ui/components/CombatPanel.vue` returns at most 1 (the mount-trigger watcher). If more, investigate and fix.
  - `grep -n 'combat-finished' src/ui/components/CombatPanel.vue` shows it emitted in the combat-end handler
  - `grep -n 'isFastForward\|getTiming\|fastForward' src/ui/components/CombatPanel.vue` still shows fast-forward intact
  - `npx vue-tsc --noEmit` -- no new type errors
  </verify>
  <done>
  State machine fully removed (CombatPanelState, panelState, sawCombatEndEvent, computeNextState, transitionState, all 4 state machine watchers). Panel lifecycle is event-driven: opens on first combat-panel snapshot, closes when combat-end handler finishes and emits combat-finished. Fast-forward untouched. Zero references to panelState, CombatPanelState, computeNextState, transitionState, sawCombatEndEvent, displayHealth, or initializeDisplayHealth.
  </done>
</task>

</tasks>

<verification>
After both tasks complete, the full Phase 44 success criteria should hold:

1. `grep -n 'combatSnapshot' src/ui/components/CombatPanel.vue` -- confirms snapshot is the data source
2. `grep -rn 'panelState\|CombatPanelState\|computeNextState\|transitionState\|sawCombatEndEvent\|displayHealth\|initializeDisplayHealth' src/ui/components/CombatPanel.vue` -- zero matches (DELETE-03, DELETE-05)
3. `grep -rn 'findElementById\|resolveCombatant\|useGameViewHelpers\|getAttr' src/ui/components/CombatPanel.vue` -- zero matches
4. `grep -c 'props\.activeCombat' src/ui/components/CombatPanel.vue` -- at most 1 (mount trigger only)
5. `grep -n 'isFastForward' src/ui/components/CombatPanel.vue` -- still present (fast-forward works)
6. `grep -n "emit('combat-finished')" src/ui/components/CombatPanel.vue` -- present in combat-end handler
7. `npx vue-tsc --noEmit` -- no type errors
</verification>

<success_criteria>
- All 5 decision prompts read from combatSnapshot decision context (UI-02)
- Panel lifecycle is event-driven: snapshot presence = open, combat-end handler = close (UI-03)
- State machine fully removed: zero refs to panelState, CombatPanelState, computeNextState, transitionState, sawCombatEndEvent (DELETE-03)
- combat-finished emitted from combat-end handler (GameTable's clearCombatAnimations triggers correctly)
- Fast-forward mechanism unchanged
- No type errors
- Combined with Plan 01: CombatPanel is a self-contained animation player rendering 100% from event data
</success_criteria>

<output>
After completion, create `.planning/phases/44-combatpanel-rebuild/44-02-SUMMARY.md`
</output>
