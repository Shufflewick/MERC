---
phase: 44-combatpanel-rebuild
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ui/components/CombatPanel.vue
  - src/ui/components/GameTable.vue
autonomous: true

must_haves:
  truths:
    - "CombatPanel renders all combatants (names, images, health, type badges) from the combat-panel snapshot, not from activeCombat prop"
    - "Health values update smoothly per-hit during animations via combat-damage healthAfter"
    - "Health values reset to snapshot-authoritative values when a new combat-panel event arrives"
    - "Header shows sector name and round number from snapshot data"
    - "CombatPanel no longer uses gameView prop or findElementById/resolveCombatant/getAttr for rendering"
  artifacts:
    - path: "src/ui/components/CombatPanel.vue"
      provides: "Snapshot-driven combatant rendering"
      contains: "combatSnapshot"
  key_links:
    - from: "combat-panel handler"
      to: "combatSnapshot ref"
      via: "animationEvents.registerHandler('combat-panel', ...)"
      pattern: "registerHandler.*combat-panel"
    - from: "combat-damage handler"
      to: "healthOverrides ref"
      via: "healthOverrides.value.set(targetId, healthAfter)"
      pattern: "healthOverrides.*set"
    - from: "getCombatantDisplay()"
      to: "combatSnapshot + healthOverrides"
      via: "reads snapshot combatant fields with healthOverrides lookup"
      pattern: "healthOverrides.*get.*combatant"
---

<objective>
Register the combat-panel snapshot handler and rewire all combatant rendering to read from snapshot data instead of activeCombat prop and gameView element resolution.

Purpose: This is the core UI-01 and DELETE-05 work -- CombatPanel stops reading combatant data from the activeCombat prop (theatre view) and instead renders from the self-contained combat-panel snapshot events emitted by Phase 43. The displayHealth manual tracking system is replaced by snapshot health + combat-damage healthAfter overrides.

Output: CombatPanel.vue renders combatants, health, and header from snapshot. GameTable no longer passes gameView prop to CombatPanel. The displayHealth/initializeDisplayHealth system and resolveCombatant/findElementById/getAttr usage are removed.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/44-combatpanel-rebuild/44-RESEARCH.md
@.planning/phases/43-combat-event-architecture/43-02-SUMMARY.md

Key reference: The combat-panel snapshot format (from RESEARCH.md):
- Top level: sectorId, sectorName, round, combatComplete, dogAssignments, 6 pending* fields
- rebelCombatants/dictatorCombatants/rebelCasualties/dictatorCasualties: SerializedCombatant[]
- SerializedCombatant: { id, name, image, health, maxHealth, isMerc, isMilitia, isAttackDog, isDictator, isDictatorSide, playerColor, combatantId, attackDogAssignedTo, attackDogTargetName, attackDogPendingTarget }
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add snapshot state, register combat-panel handler, rewire health tracking</name>
  <files>src/ui/components/CombatPanel.vue</files>
  <action>
  In the CombatPanel.vue script section, make the following changes:

  **Add new state (near line 154, alongside existing displayHealth):**
  - Add `const combatSnapshot = ref<Record<string, unknown> | null>(null);`
  - Add `const healthOverrides = ref<Map<string, number>>(new Map());`

  **Register combat-panel handler (inside the `if (animationEvents)` block, before the existing combat-roll handler on line 231):**
  ```typescript
  animationEvents.registerHandler('combat-panel', async (event) => {
    combatSnapshot.value = event.data as Record<string, unknown>;
    healthOverrides.value.clear(); // Snapshot health is authoritative at decision points
  });
  ```
  IMPORTANT: Register synchronously in setup scope (same as existing handlers). NOT in onMounted. The comment on lines 224-227 explains why.

  **Modify combat-damage handler (lines 241-262):**
  Replace the `displayHealth.value.set(...)` calls with `healthOverrides.value.set(...)`. The handler already extracts targetId and healthAfter. Change:
  - `displayHealth.value.set(targetId, healthAfter)` -> `healthOverrides.value.set(targetId, healthAfter)`
  - Remove the fallback branch that reads `displayHealth.value.get(targetId)` and computes from damage delta. The healthAfter field is always present (Phase 43 guaranteed this in SRV-03). Keep only the healthAfter branch.

  **Modify combat-heal handler (lines 292-308):**
  Add healthOverrides update. After the existing `healingCombatants.value.add(targetId)` line, add:
  ```typescript
  const healthAfter = typeof data.healthAfter === 'number' ? data.healthAfter : undefined;
  if (typeof healthAfter === 'number') {
    healthOverrides.value.set(targetId, healthAfter);
  }
  ```
  This ensures health updates smoothly during heal animations too.

  **Delete displayHealth ref (line 154):**
  Remove `const displayHealth = ref<Map<string, number>>(new Map());`

  **Delete initializeDisplayHealth function (lines 394-409):**
  Remove the entire function.

  **Delete sectorId watcher that calls initializeDisplayHealth (lines 411-413):**
  Remove `watch(() => props.activeCombat?.sectorId, () => { initializeDisplayHealth(props.activeCombat); }, { immediate: true });`

  **Update resetAnimations function (lines 321-326):**
  Replace `displayHealth.value.clear()` with `healthOverrides.value.clear()`.

  **Remove gameView prop usage (lines 7, 39, 102-103):**
  - Remove `import { useGameViewHelpers, getAttr } from '../composables/useGameViewHelpers';` (line 7)
  - Remove `gameView?: any;` from props (line 39)
  - Remove `const { findElementById } = useGameViewHelpers(() => props.gameView);` (line 103)

  **Remove resolveCombatant function (lines 559-563):**
  Delete the entire function.

  **Replace getCombatantDisplay function (lines 565-626):**
  Replace the entire body with direct reads from snapshot combatant data:
  ```typescript
  function getCombatantDisplay(combatant: any) {
    const id = String(combatant.id ?? '');
    const health = healthOverrides.value.get(id) ?? (combatant.health as number);
    const maxHealth = combatant.maxHealth as number;

    return {
      id,
      name: combatant.name as string,
      isMerc: combatant.isMerc as boolean,
      isAttackDog: combatant.isAttackDog as boolean,
      isMilitia: combatant.isMilitia as boolean,
      health,
      maxHealth,
      combatantId: (combatant.combatantId as string) || '',
      image: combatant.image as string | undefined,
      isDead: health <= 0,
      playerColor: combatant.playerColor as string | undefined,
      attackDogTargetName: combatant.attackDogTargetName as string | undefined,
      attackDogPendingTarget: combatant.attackDogPendingTarget as boolean | undefined,
    };
  }
  ```
  This eliminates all resolveCombatant/findElementById/getAttr calls. Snapshot combatants are pre-serialized plain objects with all fields present.

  **Replace displayCombat computed (line 384):**
  Change from `const displayCombat = computed(() => props.activeCombat);` to `const displayCombat = computed(() => combatSnapshot.value);`
  This makes the header's `displayCombat?.round` and sector name read from the snapshot.

  **Replace livingRebels computed (lines 434-450):**
  Replace to read from combatSnapshot instead of displayCombat:
  ```typescript
  const livingRebels = computed(() => {
    const snapshot = combatSnapshot.value;
    if (!snapshot) return [];
    const combatants = (snapshot.rebelCombatants as any[]) || [];
    const casualties = (snapshot.rebelCasualties as any[]) || [];
    const seen = new Set<string>();
    const combined: any[] = [];
    for (const c of [...combatants, ...casualties]) {
      const id = String(c?.id ?? '');
      if (id && !seen.has(id)) {
        seen.add(id);
        combined.push(c);
      }
    }
    return combined;
  });
  ```

  **Replace livingDictator computed (lines 453-469):**
  Same pattern but reading snapshot.dictatorCombatants and snapshot.dictatorCasualties.

  **Replace dogTargetNames computed (lines 497-533):**
  Simplify to read from snapshot combatants directly (they have attackDogTargetName and attackDogPendingTarget fields):
  ```typescript
  const dogTargetNames = computed(() => {
    const nameMap = new Map<string, string>();
    const allCombatants = [...livingRebels.value, ...livingDictator.value];
    for (const c of allCombatants) {
      if (!c?.isAttackDog) continue;
      const dogId = String(c.id ?? '');
      if (!dogId) continue;
      if (c.attackDogPendingTarget) {
        nameMap.set(dogId, 'Selecting...');
      } else if (c.attackDogTargetName) {
        nameMap.set(dogId, c.attackDogTargetName);
      }
    }
    return nameMap;
  });
  ```
  This removes the dogAssignments iteration and the dogs array fallback. Snapshot combatants carry this data directly.

  **Update the activeCombat watcher (lines 386-392):**
  This watcher resets UI state when combat starts. Keep the watcher but have it also clear the snapshot:
  ```typescript
  watch(() => props.activeCombat, (newCombat, oldCombat) => {
    if (newCombat && !oldCombat) {
      resetAnimations();
      healingCombatants.value.clear();
      combatSnapshot.value = null;
    }
  }, { immediate: true });
  ```

  **Remove getCombatantId function calls from livingRebels/livingDictator:**
  The old code called `getCombatantId(c)` which handled element refs with sourceElement and __elementRef. Snapshot combatants have a plain `id` field. The new code uses `String(c?.id ?? '')` directly.

  **Keep getCombatantId function itself for now** -- it is still used by findCombatantIdByName and the currentEvent watcher. It will be cleaned up in plan 02.
  </action>
  <verify>
  - `grep -n 'displayHealth' src/ui/components/CombatPanel.vue` returns zero matches
  - `grep -n 'initializeDisplayHealth' src/ui/components/CombatPanel.vue` returns zero matches
  - `grep -n 'findElementById' src/ui/components/CombatPanel.vue` returns zero matches
  - `grep -n 'resolveCombatant' src/ui/components/CombatPanel.vue` returns zero matches
  - `grep -n 'useGameViewHelpers\|getAttr' src/ui/components/CombatPanel.vue` returns zero matches
  - `grep -n 'combatSnapshot' src/ui/components/CombatPanel.vue` returns multiple matches (ref declaration, handler, displayCombat computed)
  - `grep -n 'healthOverrides' src/ui/components/CombatPanel.vue` returns multiple matches (ref, combat-damage handler, combat-heal handler, getCombatantDisplay)
  - `npx vue-tsc --noEmit` compiles without errors (or at minimum, no NEW errors in CombatPanel.vue)
  </verify>
  <done>
  CombatPanel renders all combatant data from the combat-panel snapshot. Health tracking uses snapshot health at decision points + healthOverrides from combat-damage/combat-heal events between decision points. The displayHealth system, initializeDisplayHealth, resolveCombatant, findElementById, getAttr, and gameView prop are all removed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Remove gameView prop binding from GameTable</name>
  <files>src/ui/components/GameTable.vue</files>
  <action>
  In GameTable.vue, remove the `:game-view="gameView"` prop from the CombatPanel binding (line 1256).

  The line currently reads:
  ```
  :game-view="gameView"
  ```
  Delete this entire line.

  No other changes to GameTable in this plan. The `activeCombatForPanel`, `hasActiveCombat`, `cachedCombat`, and related wiring stay intact -- they are needed to mount CombatPanel before events arrive (Pitfall 6 from RESEARCH.md). GameTable cleanup happens in Phase 45.
  </action>
  <verify>
  - `grep -n 'game-view' src/ui/components/GameTable.vue` returns zero matches in the CombatPanel section (there may be other components that use gameView -- only CombatPanel's binding should be removed)
  - The CombatPanel v-if and all event handlers remain intact
  </verify>
  <done>
  GameTable no longer passes gameView to CombatPanel. CombatPanel's rendering is fully decoupled from the gameView element tree.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `grep -rn 'displayHealth\|initializeDisplayHealth' src/ui/components/CombatPanel.vue` -- zero matches
2. `grep -rn 'findElementById\|resolveCombatant\|useGameViewHelpers\|getAttr' src/ui/components/CombatPanel.vue` -- zero matches
3. `grep -n 'combatSnapshot' src/ui/components/CombatPanel.vue` -- multiple matches confirming snapshot-driven rendering
4. `grep -n 'game-view' src/ui/components/GameTable.vue` in CombatPanel section -- zero matches
5. `npx vue-tsc --noEmit` -- no new type errors
</verification>

<success_criteria>
- CombatPanel stores latest combat-panel snapshot in combatSnapshot ref
- All combatant rendering reads from snapshot data (not activeCombat prop)
- Health tracks via snapshot + healthOverrides (not displayHealth Map)
- gameView prop removed from CombatPanel definition and GameTable binding
- resolveCombatant, findElementById, getAttr, useGameViewHelpers all removed from CombatPanel
- displayHealth, initializeDisplayHealth, sectorId watcher all removed
- No type errors introduced
</success_criteria>

<output>
After completion, create `.planning/phases/44-combatpanel-rebuild/44-01-SUMMARY.md`
</output>
