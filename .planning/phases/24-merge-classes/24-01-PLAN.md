---
phase: 24-merge-classes
plan: 01
type: execute
---

<objective>
Make CombatantModel a concrete class with unified ID properties, reducing MercCard/DictatorCard to minimal marker classes.

Purpose: Simplify class hierarchy - all combatant logic in CombatantModel, subclasses only exist for BoardSmith classRegistry.
Output: CombatantModel with combatantId/combatantName as actual properties, MercCard/DictatorCard as thin wrappers.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary-template.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-documentation/23-01-SUMMARY.md

**Current class hierarchy:**
- CombatantBase (abstract) - base stats, equipment, computed stats
- CombatantModel (abstract extends CombatantBase) - cardType, isMerc/isDictator, equip rules
- MercCard (extends CombatantModel) - mercId/mercName, cardType='merc'
- DictatorCard (extends CombatantModel) - dictatorId/dictatorName, inPlay=false

**Target class hierarchy:**
- CombatantBase (abstract) - same as before
- CombatantModel (concrete) - combatantId/combatantName properties, cardType, all behavior
- MercCard (extends CombatantModel) - marker class only, no unique properties except aliases
- DictatorCard (extends CombatantModel) - marker class only, inPlay default only

**Constraint:** classRegistry requires 'MercCard' and 'DictatorCard' class names for deserialization.

**Key insight:** CombatantBase has abstract getters for combatantId/combatantName. We need to:
1. Make CombatantModel concrete by adding _combatantId/_combatantName properties
2. Update MercCard/DictatorCard to set these properties in a way that works with BoardSmith's create()
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ID properties to CombatantModel</name>
  <files>src/rules/elements.ts</files>
  <action>
Add _combatantId and _combatantName properties to CombatantModel:

1. Add private properties:
   - `_combatantId: string = '';`
   - `_combatantName: string = '';`

2. Implement the abstract getters from CombatantBase:
   - `get combatantId(): string { return this._combatantId; }`
   - `get combatantName(): string { return this._combatantName; }`

3. Add setters for BoardSmith's create() to use:
   - `set combatantId(value: string) { this._combatantId = value; }`
   - `set combatantName(value: string) { this._combatantName = value; }`

4. Remove the `abstract` keyword from CombatantModel class declaration.

This makes CombatantModel concrete while preserving the getter API.
  </action>
  <verify>npm run build passes (may have errors in subclasses - addressed in next task)</verify>
  <done>CombatantModel has _combatantId/_combatantName properties with getters/setters</done>
</task>

<task type="auto">
  <name>Task 2: Simplify MercCard to use parent properties</name>
  <files>src/rules/elements.ts</files>
  <action>
Update MercCard to use CombatantModel's properties instead of its own:

1. Keep mercId and mercName as properties (BoardSmith populates these from JSON)
2. Change combatantId/combatantName getters to delegate:
   - `override get combatantId(): string { return this.mercId || this._combatantId; }`
   - `override get combatantName(): string { return this.mercName || this._combatantName; }`
3. Add setters that set both:
   - `override set combatantId(value: string) { this._combatantId = value; this.mercId = value; }`
   - `override set combatantName(value: string) { this._combatantName = value; this.mercName = value; }`

This maintains backward compatibility: code setting mercId still works, code setting combatantId also works.
  </action>
  <verify>npm run build passes</verify>
  <done>MercCard uses parent properties with backward-compat mercId/mercName aliases</done>
</task>

<task type="auto">
  <name>Task 3: Simplify DictatorCard to use parent properties</name>
  <files>src/rules/elements.ts</files>
  <action>
Update DictatorCard similarly to MercCard:

1. Keep dictatorId and dictatorName as properties (BoardSmith populates these from JSON)
2. Change combatantId/combatantName getters to delegate:
   - `override get combatantId(): string { return this.dictatorId || this._combatantId; }`
   - `override get combatantName(): string { return this.dictatorName || this._combatantName; }`
3. Add setters that set both:
   - `override set combatantId(value: string) { this._combatantId = value; this.dictatorId = value; }`
   - `override set combatantName(value: string) { this._combatantName = value; this.dictatorName = value; }`

Same pattern as MercCard for consistency.
  </action>
  <verify>npm run build passes, npm test passes</verify>
  <done>DictatorCard uses parent properties with backward-compat dictatorId/dictatorName aliases</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm test` passes (same as baseline - 56 pre-existing failures in action-conditions.test.ts)
- [ ] CombatantModel is no longer abstract
- [ ] MercCard.combatantId returns the same value as mercId
- [ ] DictatorCard.combatantId returns the same value as dictatorId
</verification>

<success_criteria>
- CombatantModel has _combatantId/_combatantName properties with getters/setters
- MercCard and DictatorCard delegate to parent while maintaining backward-compat aliases
- All existing code continues to work (no behavioral changes)
- Build and tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/24-merge-classes/24-01-SUMMARY.md`
</output>
