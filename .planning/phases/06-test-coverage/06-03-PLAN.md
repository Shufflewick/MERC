---
phase: 06-test-coverage
plan: 03
type: execute
---

<objective>
Add tests for error conditions and edge cases to ensure graceful handling of unexpected states.

Purpose: Cover the test gap for error handling - many error paths are untested, risking unhandled errors crashing the game.
Output: New test file `tests/error-conditions.test.ts` with error handling coverage.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-test-coverage/06-01-SUMMARY.md
@.planning/phases/06-test-coverage/06-02-SUMMARY.md

**Type assertion helpers that throw (from helpers.ts):**
- `asRebelPlayer(player)` - throws if not RebelPlayer
- `asMercCard(element)` - throws if not MercCard
- `asSector(element)` - throws if not Sector
- `asSquad(element)` - throws if not Squad
- `asTacticsCard(element)` - throws if not TacticsCard
- `asEquipment(element)` - throws if not Equipment

**Type guards that return boolean:**
- `isRebelPlayer(player)` - returns false for non-rebel
- `isDictatorCard(unit)` - returns false for non-dictator

**Helper functions with potential edge cases:**
- `canHireMercWithTeam(mercId, team)` - MERC compatibility check
- `hasActionsRemaining(player, cost)` - action point check
- `findUnitSector(unit, player, game)` - returns null on not found
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error-conditions.test.ts with type assertion error tests</name>
  <files>tests/error-conditions.test.ts</files>
  <action>
Create new test file for error condition testing.

1. Test type assertion helpers throw correctly:
   - `asRebelPlayer` throws with descriptive message for DictatorPlayer
   - `asRebelPlayer` throws for null/undefined
   - `asMercCard` throws for non-MercCard elements
   - `asSector` throws for non-Sector elements
   - `asSquad` throws for non-Squad elements
   - `asEquipment` throws for non-Equipment elements

2. Test error messages are descriptive:
   - Include expected type in message
   - Include actual type in message
   - Help debugging (not just "assertion failed")

3. Test type guards don't throw:
   - `isRebelPlayer` returns false (not throws) for wrong type
   - `isDictatorCard` returns false (not throws) for wrong type

Use `expect(...).toThrow()` and `expect(...).toThrowError(/pattern/)` for error tests.
  </action>
  <verify>npm test -- tests/error-conditions.test.ts --run passes</verify>
  <done>Type assertion error tests pass, verifying throws and error messages</done>
</task>

<task type="auto">
  <name>Task 2: Add helper function edge case tests</name>
  <files>tests/error-conditions.test.ts</files>
  <action>
Add tests for helper function edge cases:

1. Test `canHireMercWithTeam` edge cases:
   - Empty team allows any MERC
   - Unknown MERC ID (not in incompatibilities) works
   - Bidirectional incompatibility (A blocks B, B blocks A)
   - Multiple team members with different incompatibilities

2. Test `findUnitSector` edge cases:
   - Returns null for unit not in any sector
   - Returns null for null/undefined unit
   - Works for rebel squads
   - Works for dictator units

3. Test `hasActionsRemaining` edge cases:
   - Returns false for empty team
   - Returns false when all MERCs exhausted
   - Returns true when at least one MERC has actions

4. Test action cost edge cases:
   - Zero cost actions (split/merge)
   - Actions requiring more than available

These tests protect against runtime errors in edge cases.
  </action>
  <verify>npm test -- tests/error-conditions.test.ts --run passes</verify>
  <done>Helper edge case tests pass, covering empty arrays, null returns, and boundary conditions</done>
</task>

<task type="auto">
  <name>Task 3: Add game state edge case tests</name>
  <files>tests/error-conditions.test.ts</files>
  <action>
Add tests for game state edge cases:

1. Test empty deck scenarios:
   - MERC deck exhausted
   - Equipment decks exhausted
   - Tactics deck exhausted

2. Test boundary conditions:
   - Day counter at extremes
   - Zero credits operations
   - Maximum team size

3. Test null/missing element handling:
   - Sector lookup with invalid ID
   - Player lookup edge cases
   - Equipment not found scenarios

Focus on conditions that could cause runtime crashes if not handled.
  </action>
  <verify>npm test -- tests/error-conditions.test.ts --run passes with all tests green</verify>
  <done>Game state edge case tests pass, covering empty decks, boundaries, and null handling</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm test -- tests/error-conditions.test.ts --run` passes
- [ ] Type assertion helpers verified to throw descriptive errors
- [ ] Helper function edge cases tested (empty, null, boundaries)
- [ ] Game state edge cases tested (empty decks, limits)
- [ ] No TypeScript errors
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Error messages are descriptive and helpful for debugging
- Edge cases don't cause unhandled exceptions
- Phase 6 complete after this plan
</success_criteria>

<output>
After completion, create `.planning/phases/06-test-coverage/06-03-SUMMARY.md` with:
- Phase 6 complete indication
- Summary of test files added
- Total test count increase
- Any deferred issues discovered
</output>
