---
phase: 51-extract-combat-sub-flow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/rules/flow.ts
autonomous: true

must_haves:
  truths:
    - "Combat triggered during rebel phase resolves through the extracted sub-flow"
    - "Combat triggered during dictator phase resolves through the same extracted sub-flow"
    - "Combat triggered by tactics cards resolves through the same extracted sub-flow"
    - "Combat triggered by Kim militia resolves through the same extracted sub-flow"
    - "All existing tests pass without modification"
  artifacts:
    - path: "src/rules/flow.ts"
      provides: "combatResolutionFlow function and 4 call sites"
      contains: "function combatResolutionFlow"
  key_links:
    - from: "combatResolutionFlow"
      to: "rebel-action-loop sequence"
      via: "combatResolutionFlow(game, 'combat')"
      pattern: "combatResolutionFlow\\(game,\\s*'combat'"
    - from: "combatResolutionFlow"
      to: "tactics combat sequence"
      via: "combatResolutionFlow(game, 'tactics-combat')"
      pattern: "combatResolutionFlow\\(game,\\s*'tactics-combat'"
    - from: "combatResolutionFlow"
      to: "dictator-merc-actions sequence"
      via: "combatResolutionFlow(game, 'dictator-combat')"
      pattern: "combatResolutionFlow\\(game,\\s*'dictator-combat'"
    - from: "combatResolutionFlow"
      to: "kim-militia-combat sequence"
      via: "combatResolutionFlow(game, 'kim-militia-combat')"
      pattern: "combatResolutionFlow\\(game,\\s*'kim-militia-combat'"
---

<objective>
Extract the combat resolution flow that is duplicated 4 times in flow.ts into a single `combatResolutionFlow(game, prefix)` function, then replace all 4 inline copies with calls to this function.

Purpose: Eliminate ~900 lines of duplication to prepare for Phase 52+ where combat resolution will be invoked from a shared sub-flow rather than copy-pasted inline. This is the foundation for simultaneous rebel turns.

Output: A single `flow.ts` with one `combatResolutionFlow` function called from 4 sites, ~900 fewer lines, identical behavior.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/51-extract-combat-sub-flow/51-RESEARCH.md
@src/rules/flow.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify duplication and extract combatResolutionFlow function</name>
  <files>src/rules/flow.ts</files>
  <action>
First, verify that all 4 combat resolution blocks are functionally identical (only loop name prefixes differ). The 4 sites per RESEARCH.md:

1. **Rebel action loop**: lines ~396-630 (prefix: `combat-*` on loops, but the first one is just `combat-before-attack-healing` without a rebel prefix)
2. **Tactics card combat**: lines ~807-1037 (prefix: `tactics-combat-*`)
3. **Dictator MERC actions**: lines ~1079-1309 (prefix: `dictator-combat-*`)
4. **Kim militia combat**: lines ~1396-1626 (prefix: `kim-militia-combat-*`)

Diff the content of each block (ignoring loop name prefixes) to confirm they are identical. If any differences exist beyond the prefix, investigate which version is correct and use the correct logic.

Then create a `combatResolutionFlow` function in flow.ts at module scope (near the helper functions like `getCombatDecisionPlayer` that it uses). The function signature:

```typescript
function combatResolutionFlow(game: MERCGame, prefix: string) {
  return sequence(
    // All 10 combat resolution blocks go here
    // Loop names use template strings: `${prefix}-before-attack-healing`, etc.
    // Inner actionStep names stay the same (they are scoped by parent loop)
  );
}
```

The function contains these 10 blocks in order:
1. Before-attack healing loop
2. Attack dog selection loop
3. Target selection loop
4. Hit allocation loop
5. Wolverine 6s loop
6. Epinephrine loop
7. Combat continue loop (non-retreat, handles combat round continuation)
8. Retreat decision loop (simultaneousActionStep + execute for retreat processing)
9. Auto-clear execute (for all-AI games)
10. Animation wait loop

IMPORTANT things to NOT extract:
- The **pending combat initiation** `execute` blocks that appear BEFORE the combat resolution in 3 of the 4 sites (rebel, dictator, Kim). These are context-dependent and must stay inline.
- The regular **action steps** (`rebel-action`, `dictator-merc-action`) that appear AFTER the combat resolution. These stay inline.
- Any `skipIf` logic on the parent loops/action steps that surround the combat blocks.

For the loop name prefix, match the existing convention:
- Rebel site: pass `'combat'` (the current prefix is just `combat-*`, no `rebel-` prefix)
- Tactics site: pass `'tactics-combat'`
- Dictator site: pass `'dictator-combat'`
- Kim militia site: pass `'kim-militia-combat'`
  </action>
  <verify>
Confirm the function exists by searching for `function combatResolutionFlow` in flow.ts. Confirm exactly 4 call sites by searching for `combatResolutionFlow(game,` -- should find exactly 4 matches. Count lines in flow.ts -- should be ~750 lines (down from 1648, removing ~900 lines of duplication).
  </verify>
  <done>
combatResolutionFlow function exists in flow.ts. All 4 inline combat blocks replaced with single function calls. No other behavioral changes. File is significantly shorter.
  </done>
</task>

<task type="auto">
  <name>Task 2: Run full test suite to verify no behavioral regression</name>
  <files>src/rules/flow.ts</files>
  <action>
Run `npm test` (vitest --run) to execute the full test suite. Every test must pass without modification.

Pay special attention to:
- `tests/smoke.test.ts` -- exercises the full game flow with AI players, most sensitive to flow structure changes
- `tests/combat-events.test.ts` -- tests combat animation pipeline
- `tests/combat-execution.test.ts` -- tests combat mechanics
- `tests/combat-abilities.test.ts` -- tests MERC abilities in combat
- `tests/landmine.test.ts` -- tests combat triggered by landmine

If any test fails, the extraction introduced a behavioral difference. Compare the failing test's expected flow path against the extracted function to find the discrepancy. Fix the extraction, do NOT modify tests.

Also run `npm run validate` (boardsmith validate) to check flow structure validity.
  </action>
  <verify>
`npm test` exits with code 0, all tests pass. `npm run validate` exits with code 0.
  </verify>
  <done>
Full test suite passes. BoardSmith validation passes. The extraction is a pure refactoring with no behavioral changes.
  </done>
</task>

</tasks>

<verification>
1. `grep -c 'combatResolutionFlow' src/rules/flow.ts` returns 5 (1 definition + 4 calls)
2. `npm test` passes all tests
3. `npm run validate` passes
4. flow.ts line count is significantly reduced from 1648 (target: ~750 lines)
</verification>

<success_criteria>
- combatResolutionFlow function exists and encapsulates all 10 combat resolution blocks
- All 4 inline duplication sites replaced with single function calls
- All existing tests pass without modification
- BoardSmith validation passes
- flow.ts reduced by ~900 lines
</success_criteria>

<output>
After completion, create `.planning/phases/51-extract-combat-sub-flow/51-01-SUMMARY.md`
</output>
