---
phase: 38-unify-server-side-calculation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/rules/elements.ts
autonomous: true

must_haves:
  truths:
    - "CombatantModel has activeStatModifiers property"
    - "updateAbilityBonuses() builds context and calls getActiveStatModifiers()"
    - "getAbilityBonus() sums modifiers for a stat with correct target filtering"
  artifacts:
    - path: "src/rules/elements.ts"
      provides: "activeStatModifiers property, updateAbilityBonuses method, buildStatModifierContext helper, getAbilityBonus helper"
      contains: "activeStatModifiers"
  key_links:
    - from: "src/rules/elements.ts"
      to: "src/rules/merc-abilities.ts"
      via: "imports getActiveStatModifiers, StatModifier, StatModifierContext, FEMALE_MERCS"
      pattern: "import.*getActiveStatModifiers.*from.*merc-abilities"
---

<objective>
Add unified stat modifier infrastructure to CombatantBase

Purpose: Create the foundation for unified ability stat calculations - the activeStatModifiers property, context builder, and helper methods that will replace 20+ individual bonus fields.

Output: CombatantBase with activeStatModifiers array, updateAbilityBonuses() method, and getAbilityBonus() helper
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/38-unify-server-side-calculation/38-RESEARCH.md

@src/rules/elements.ts
@src/rules/merc-abilities.ts
@src/rules/equipment-effects.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add imports and activeStatModifiers property</name>
  <files>src/rules/elements.ts</files>
  <action>
Add imports from merc-abilities.ts at the top of elements.ts:
```typescript
import {
  getMercAbility,
  ignoresInitiativePenalties,
  FEMALE_MERCS,
  getActiveStatModifiers,
  StatModifier,
  StatModifierContext,
} from './merc-abilities.js';
```

Note: FEMALE_MERCS is already imported. Add the other three to the existing import statement.

Add new property to CombatantBase after the existing bonus fields (around line 150, after `tavistoWomanTrainingBonus`):

```typescript
// Unified stat modifiers from ability registry (Phase 38)
// This array holds ALL active stat modifiers including squad-received bonuses
activeStatModifiers: StatModifier[] = [];
```

This single array will eventually replace all the individual bonus fields (haargTrainingBonus, sargeTrainingBonus, etc.) but we keep those for now for backward compatibility.
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors</verify>
  <done>CombatantBase has activeStatModifiers property and imports StatModifier, StatModifierContext, getActiveStatModifiers from merc-abilities.ts</done>
</task>

<task type="auto">
  <name>Task 2: Add buildStatModifierContext helper</name>
  <files>src/rules/elements.ts</files>
  <action>
Add a private helper method to CombatantBase after `getBaseStatWithEquip()` (around line 259):

```typescript
/**
 * Build context object for getActiveStatModifiers().
 * Used to evaluate ability conditions like hasHandgun, isAlone, etc.
 */
protected buildStatModifierContext(squadMates: CombatantBase[]): StatModifierContext {
  const weaponId = this.weaponSlot?.equipmentId || this.weaponSlotData?.equipmentId;
  const armorId = this.armorSlot?.equipmentId || this.armorSlotData?.equipmentId;
  const accessoryId = this.accessorySlot?.equipmentId || this.accessorySlotData?.equipmentId;
  const weaponTargets = this.weaponSlot?.targets ?? this.weaponSlotData?.targets ?? 0;
  const weaponName = this.weaponSlot?.equipmentName || this.weaponSlotData?.equipmentName || '';

  // Determine weapon type using equipment-effects helpers
  let weaponType: string | undefined;
  if (weaponId) {
    if (isHandgun(weaponId)) weaponType = 'handgun';
    else if (isUzi(weaponId)) weaponType = 'uzi';
    else if (isExplosive(weaponId)) weaponType = 'grenade'; // Phase 37 condition expects 'grenade' or 'mortar'
    else if (isSmaw(weaponId)) weaponType = 'smaw';
  }

  // Check for explosive in accessory/bandolier (for Stumpy)
  const hasExplosiveInAccessory = accessoryId && isExplosive(accessoryId);
  const hasExplosiveInBandolier = this.bandolierSlots.some(e => e?.equipmentId && isExplosive(e.equipmentId)) ||
                                  this.bandolierSlotsData.some(d => d?.equipmentId && isExplosive(d.equipmentId));
  const hasExplosiveEquipped = hasExplosiveInAccessory || hasExplosiveInBandolier || weaponType === 'grenade';

  // Filter living squad mates (excluding self)
  const livingMates = squadMates.filter(m => m.combatantId !== this.combatantId && !m.isDead);

  // Check if this MERC has highest initiative in squad (for Sarge, Tack)
  // Uses BASE initiative only (before equipment/bonuses)
  let isHighestInitInSquad = false;
  if (livingMates.length > 0) {
    isHighestInitInSquad = livingMates.every(mate => mate.baseInitiative < this.baseInitiative);
  }

  return {
    equipment: {
      weapon: weaponId ? {
        name: weaponName,
        type: weaponType,
        targets: weaponTargets,
      } : undefined,
      armor: armorId ? { name: this.armorSlot?.equipmentName || this.armorSlotData?.equipmentName || '' } : undefined,
      accessory: accessoryId ? { name: this.accessorySlot?.equipmentName || this.accessorySlotData?.equipmentName || '' } : undefined,
      // Extension for Stumpy's explosive check (not in original StatModifierContext but used internally)
      hasExplosiveEquipped,
    } as StatModifierContext['equipment'] & { hasExplosiveEquipped?: boolean },
    squadMates: livingMates.map(m => ({
      combatantId: m.combatantId,
      baseCombat: m.baseCombat,
      baseInitiative: m.baseInitiative,
      baseTraining: m.baseTraining,
    })),
    isAlone: livingMates.length === 0,
    hasWomanInSquad: squadMates.some(m => !m.isDead && FEMALE_MERCS.includes(m.combatantId)),
    isHighestInitInSquad,
  };
}
```

Key decisions:
- Uses equipment-effects.ts helpers (isHandgun, isUzi, isExplosive, isSmaw) for weapon type determination
- Adds hasExplosiveEquipped for Stumpy's accessory-based explosive check
- Uses BASE initiative for highestInitInSquad (per research, Sarge/Tack check base initiative)
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors</verify>
  <done>CombatantBase has buildStatModifierContext() helper that builds complete context for condition evaluation</done>
</task>

<task type="auto">
  <name>Task 3: Add updateAbilityBonuses and getAbilityBonus helpers</name>
  <files>src/rules/elements.ts</files>
  <action>
Add two new methods to CombatantBase after buildStatModifierContext():

```typescript
/**
 * Update ability bonuses from registry.
 * Call this when equipment changes or squad composition changes.
 *
 * @param squadMates - All MERCs in the same squad (including self)
 */
updateAbilityBonuses(squadMates: CombatantBase[] = []): void {
  const context = this.buildStatModifierContext(squadMates);

  // Get this MERC's own active modifiers
  const selfModifiers = getActiveStatModifiers(this.combatantId, context);

  // Filter to self-only modifiers (target undefined or 'self')
  const selfOnlyModifiers = selfModifiers.filter(m => !m.target || m.target === 'self');

  // Get squad-wide bonuses from OTHER squad mates that affect this MERC
  const receivedFromSquad = this.getReceivedSquadModifiers(squadMates, context);

  // Combine all modifiers that affect this MERC
  this.activeStatModifiers = [...selfOnlyModifiers, ...receivedFromSquad];

  // SPECIAL CASE: Haarg's per-stat bonus evaluation
  // Haarg gets +1 to each stat where a squad mate has higher BASE
  if (this.combatantId === 'haarg') {
    this.applyHaargPerStatModifiers(squadMates);
  }

  // Update computed stats with new modifiers
  this.updateComputedStats();
}

/**
 * Get modifiers received from squad mates (Tack, Valkyrie bonuses).
 */
private getReceivedSquadModifiers(squadMates: CombatantBase[], selfContext: StatModifierContext): StatModifier[] {
  const received: StatModifier[] = [];

  for (const mate of squadMates) {
    if (mate.combatantId === this.combatantId || mate.isDead) continue;

    // Build context for the squad mate
    const mateContext = mate.buildStatModifierContext(squadMates);
    const mateModifiers = getActiveStatModifiers(mate.combatantId, mateContext);

    for (const mod of mateModifiers) {
      // Check if this modifier applies to squad mates or all squad
      if (mod.target === 'squadMates') {
        // squadMates excludes the source (Valkyrie doesn't get her own bonus)
        received.push({
          ...mod,
          label: mod.label || `${mate.combatantName}'s Ability`,
        });
      } else if (mod.target === 'allSquad') {
        // allSquad includes everyone (Tack gives +2 to everyone including herself)
        received.push({
          ...mod,
          label: mod.label || `${mate.combatantName}'s Ability`,
        });
      }
    }
  }

  // Also add allSquad bonuses from SELF (Tack gets her own +2)
  const selfAllSquad = getActiveStatModifiers(this.combatantId, selfContext)
    .filter(m => m.target === 'allSquad');
  for (const mod of selfAllSquad) {
    received.push({
      ...mod,
      label: mod.label || "Squad Bonus",
    });
  }

  return received;
}

/**
 * SPECIAL: Apply Haarg's per-stat bonus.
 * Haarg gets +1 to each stat where a living squad mate has higher BASE stat.
 * This is evaluated per-stat, not as a blanket condition.
 */
private applyHaargPerStatModifiers(squadMates: CombatantBase[]): void {
  const livingMates = squadMates.filter(m => m.combatantId !== 'haarg' && !m.isDead);

  // Remove any existing Haarg modifiers (they use squadMateHigherBase condition)
  this.activeStatModifiers = this.activeStatModifiers.filter(
    m => m.condition !== 'squadMateHigherBase'
  );

  // Check each stat individually
  const hasHigherCombat = livingMates.some(m => m.baseCombat > this.baseCombat);
  const hasHigherInitiative = livingMates.some(m => m.baseInitiative > this.baseInitiative);
  const hasHigherTraining = livingMates.some(m => m.baseTraining > this.baseTraining);

  if (hasHigherCombat) {
    this.activeStatModifiers.push({ stat: 'combat', bonus: 1, label: "Haarg's Ability" });
  }
  if (hasHigherInitiative) {
    this.activeStatModifiers.push({ stat: 'initiative', bonus: 1, label: "Haarg's Ability" });
  }
  if (hasHigherTraining) {
    this.activeStatModifiers.push({ stat: 'training', bonus: 1, label: "Haarg's Ability" });
  }
}

/**
 * Get total ability bonus for a specific stat from activeStatModifiers.
 * Only includes self-targeting modifiers (already filtered in updateAbilityBonuses).
 */
protected getAbilityBonus(stat: StatModifier['stat']): number {
  return this.activeStatModifiers
    .filter(m => m.stat === stat)
    .reduce((sum, m) => sum + m.bonus, 0);
}
```

Key design decisions:
- `updateAbilityBonuses` is the single entry point (replaces updateHaargBonus, updateSargeBonus, etc.)
- `getReceivedSquadModifiers` handles Tack's allSquad and Valkyrie's squadMates bonuses
- Haarg's per-stat evaluation is special-cased (can't be expressed in generic condition system)
- `getAbilityBonus` sums all modifiers for a stat (for use in updateComputedStats)
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors</verify>
  <done>CombatantBase has updateAbilityBonuses() method that builds unified activeStatModifiers array, including squad-received bonuses and Haarg special handling</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `npx tsc --noEmit` compiles without errors
2. `npm test` passes (no behavioral changes yet)
3. CombatantBase has: activeStatModifiers property, buildStatModifierContext(), updateAbilityBonuses(), getReceivedSquadModifiers(), applyHaargPerStatModifiers(), getAbilityBonus()
</verification>

<success_criteria>
- CombatantBase has activeStatModifiers: StatModifier[] property
- buildStatModifierContext() returns complete context with equipment, squadMates, conditions
- updateAbilityBonuses() populates activeStatModifiers from registry
- getAbilityBonus() sums modifiers for a given stat
- Haarg's per-stat evaluation works correctly
- Squad-received bonuses (Tack, Valkyrie) included in activeStatModifiers
- All existing tests pass (no behavioral changes yet - old bonus fields still used)
</success_criteria>

<output>
After completion, create `.planning/phases/38-unify-server-side-calculation/38-01-SUMMARY.md`
</output>
