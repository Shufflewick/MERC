---
phase: 38-unify-server-side-calculation
plan: 02
type: execute
wave: 2
depends_on: [38-01]
files_modified:
  - src/rules/elements.ts
  - src/rules/game.ts
autonomous: true

must_haves:
  truths:
    - "updateComputedStats reads from getAbilityBonus instead of individual bonus fields"
    - "game.ts updateSquadBonuses calls updateAbilityBonuses"
    - "effectiveCombat, effectiveTraining, effectiveInitiative compute correctly"
  artifacts:
    - path: "src/rules/elements.ts"
      provides: "Updated updateComputedStats using getAbilityBonus"
      contains: "getAbilityBonus"
    - path: "src/rules/game.ts"
      provides: "Updated updateSquadBonuses calling updateAbilityBonuses"
      contains: "updateAbilityBonuses"
  key_links:
    - from: "src/rules/elements.ts updateComputedStats"
      to: "getAbilityBonus"
      via: "method call for each stat"
      pattern: "this\\.getAbilityBonus\\("
    - from: "src/rules/game.ts updateSquadBonuses"
      to: "merc.updateAbilityBonuses"
      via: "loop over squad mercs"
      pattern: "merc\\.updateAbilityBonuses"
---

<objective>
Integrate unified stat calculation into elements.ts and game.ts

Purpose: Replace the hardcoded bonus field additions in updateComputedStats() and the multiple updateXBonus() calls in game.ts with the unified system from Plan 01. This completes the server-side unification.

Output: updateComputedStats() uses getAbilityBonus(), game.ts uses single updateAbilityBonuses() call, all tests pass
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/38-unify-server-side-calculation/38-RESEARCH.md
@.planning/phases/38-unify-server-side-calculation/38-01-SUMMARY.md

@src/rules/elements.ts
@src/rules/game.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update updateComputedStats to use getAbilityBonus</name>
  <files>src/rules/elements.ts</files>
  <action>
Modify `updateComputedStats()` in CombatantBase (around line 265-309) to use the unified `getAbilityBonus()` helper instead of individual bonus field additions.

BEFORE (lines 272-284, training section):
```typescript
// Training
let t = this.baseTraining;
t += this.getEquipValue(this.weaponSlot, this.weaponSlotData, 'training');
t += this.getEquipValue(this.armorSlot, this.armorSlotData, 'training');
t += this.getEquipValue(this.accessorySlot, this.accessorySlotData, 'training');
for (let idx = 0; idx < this.bandolierSlotsData.length; idx++) {
  t += this.getEquipValue(this.bandolierSlots[idx], this.bandolierSlotsData[idx], 'training');
}
if (this.combatantId === 'haarg') t += this.haargTrainingBonus || 0;
if (this.combatantId === 'sarge') t += this.sargeTrainingBonus || 0;
t += this.snakeSoloTrainingBonus || 0;
t += this.tavistoWomanTrainingBonus || 0;
this.effectiveTraining = t;
```

AFTER (unified):
```typescript
// Training
let t = this.baseTraining;
t += this.getEquipValue(this.weaponSlot, this.weaponSlotData, 'training');
t += this.getEquipValue(this.armorSlot, this.armorSlotData, 'training');
t += this.getEquipValue(this.accessorySlot, this.accessorySlotData, 'training');
for (let idx = 0; idx < this.bandolierSlotsData.length; idx++) {
  t += this.getEquipValue(this.bandolierSlots[idx], this.bandolierSlotsData[idx], 'training');
}
// Unified ability bonus from activeStatModifiers
t += this.getAbilityBonus('training');
this.effectiveTraining = t;
```

BEFORE (lines 289-308, combat section):
```typescript
// Combat
let c = this.baseCombat;
c += this.getEquipValue(this.weaponSlot, this.weaponSlotData, 'combatBonus');
c += this.getEquipValue(this.armorSlot, this.armorSlotData, 'combatBonus');
c += this.getEquipValue(this.accessorySlot, this.accessorySlotData, 'combatBonus');
for (let idx = 0; idx < this.bandolierSlotsData.length; idx++) {
  c += this.getEquipValue(this.bandolierSlots[idx], this.bandolierSlotsData[idx], 'combatBonus');
}
if (this.combatantId === 'haarg') c += this.haargCombatBonus || 0;
if (this.combatantId === 'sarge') c += this.sargeCombatBonus || 0;
c += ability?.passive?.extraCombat || 0;
c += this.boubaHandgunCombatBonus || 0;
c += this.mayhemUziCombatBonus || 0;
c += this.rozeskeArmorCombatBonus || 0;
c += this.stumpyExplosiveCombatBonus || 0;
c += this.vandradiMultiTargetCombatBonus || 0;
c += this.dutchUnarmedCombatBonus || 0;
c += this.snakeSoloCombatBonus || 0;
c += this.tavistoWomanCombatBonus || 0;
this.effectiveCombat = Math.max(0, c);
```

AFTER (unified):
```typescript
// Combat
let c = this.baseCombat;
c += this.getEquipValue(this.weaponSlot, this.weaponSlotData, 'combatBonus');
c += this.getEquipValue(this.armorSlot, this.armorSlotData, 'combatBonus');
c += this.getEquipValue(this.accessorySlot, this.accessorySlotData, 'combatBonus');
for (let idx = 0; idx < this.bandolierSlotsData.length; idx++) {
  c += this.getEquipValue(this.bandolierSlots[idx], this.bandolierSlotsData[idx], 'combatBonus');
}
// Unified ability bonus from activeStatModifiers
c += this.getAbilityBonus('combat');
this.effectiveCombat = Math.max(0, c);
```

Also update the `effectiveInitiative` calculation. Currently it calls `this.getEffectiveInitiative()` (line 287). The `getEffectiveInitiative()` method (lines 494-520) also needs updating.

Update `getEffectiveInitiative()` method:

BEFORE (lines 494-520):
```typescript
getEffectiveInitiative(): number {
  let value = this.baseInitiative;
  const ignoresPenalties = ignoresInitiativePenalties(this.combatantId);

  const addInitiative = (initValue: number) => {
    if (ignoresPenalties && initValue < 0) return;
    value += initValue;
  };

  addInitiative(this.getEquipValue(this.weaponSlot, this.weaponSlotData, 'initiative'));
  addInitiative(this.getEquipValue(this.armorSlot, this.armorSlotData, 'initiative'));
  addInitiative(this.getEquipValue(this.accessorySlot, this.accessorySlotData, 'initiative'));

  for (let idx = 0; idx < this.bandolierSlotsData.length; idx++) {
    addInitiative(this.getEquipValue(this.bandolierSlots[idx], this.bandolierSlotsData[idx], 'initiative'));
  }

  if (this.combatantId === 'haarg') value += this.haargInitiativeBonus || 0;
  if (this.combatantId === 'sarge') value += this.sargeInitiativeBonus || 0;
  if (this.tackSquadInitiativeBonus > 0) value += this.tackSquadInitiativeBonus;
  if (this.valkyrieSquadInitiativeBonus > 0) value += this.valkyrieSquadInitiativeBonus;
  value += this.dutchUnarmedInitiativeBonus || 0;
  value += this.snakeSoloInitiativeBonus || 0;
  value += this.tavistoWomanInitiativeBonus || 0;

  return value;
}
```

AFTER (unified):
```typescript
getEffectiveInitiative(): number {
  let value = this.baseInitiative;
  const ignoresPenalties = ignoresInitiativePenalties(this.combatantId);

  const addInitiative = (initValue: number) => {
    if (ignoresPenalties && initValue < 0) return;
    value += initValue;
  };

  addInitiative(this.getEquipValue(this.weaponSlot, this.weaponSlotData, 'initiative'));
  addInitiative(this.getEquipValue(this.armorSlot, this.armorSlotData, 'initiative'));
  addInitiative(this.getEquipValue(this.accessorySlot, this.accessorySlotData, 'initiative'));

  for (let idx = 0; idx < this.bandolierSlotsData.length; idx++) {
    addInitiative(this.getEquipValue(this.bandolierSlots[idx], this.bandolierSlotsData[idx], 'initiative'));
  }

  // Unified ability bonus from activeStatModifiers
  value += this.getAbilityBonus('initiative');

  return value;
}
```

IMPORTANT: Do NOT remove updateEquipmentBonuses() call from the top of updateComputedStats() yet. Keep it for backward compatibility until combat.ts is updated in Phase 40.
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors</verify>
  <done>updateComputedStats() and getEffectiveInitiative() use getAbilityBonus() for all stat calculations</done>
</task>

<task type="auto">
  <name>Task 2: Update stat getters to use unified calculation</name>
  <files>src/rules/elements.ts</files>
  <action>
Update the `initiative`, `training`, and `combat` getters (lines 473-556) to use `getAbilityBonus()` instead of individual bonus fields.

BEFORE initiative getter (lines 473-489):
```typescript
get initiative(): number {
  let value = this.baseInitiative;
  value += this.getEquipValue(this.weaponSlot, this.weaponSlotData, 'initiative');
  value += this.getEquipValue(this.armorSlot, this.armorSlotData, 'initiative');
  value += this.getEquipValue(this.accessorySlot, this.accessorySlotData, 'initiative');
  for (let idx = 0; idx < this.bandolierSlotsData.length; idx++) {
    value += this.getEquipValue(this.bandolierSlots[idx], this.bandolierSlotsData[idx], 'initiative');
  }
  if (this.combatantId === 'haarg') value += this.haargInitiativeBonus || 0;
  if (this.combatantId === 'sarge') value += this.sargeInitiativeBonus || 0;
  if (this.tackSquadInitiativeBonus > 0) value += this.tackSquadInitiativeBonus;
  if (this.valkyrieSquadInitiativeBonus > 0) value += this.valkyrieSquadInitiativeBonus;
  value += this.dutchUnarmedInitiativeBonus || 0;
  value += this.snakeSoloInitiativeBonus || 0;
  value += this.tavistoWomanInitiativeBonus || 0;
  return value;
}
```

AFTER initiative getter:
```typescript
get initiative(): number {
  let value = this.baseInitiative;
  value += this.getEquipValue(this.weaponSlot, this.weaponSlotData, 'initiative');
  value += this.getEquipValue(this.armorSlot, this.armorSlotData, 'initiative');
  value += this.getEquipValue(this.accessorySlot, this.accessorySlotData, 'initiative');
  for (let idx = 0; idx < this.bandolierSlotsData.length; idx++) {
    value += this.getEquipValue(this.bandolierSlots[idx], this.bandolierSlotsData[idx], 'initiative');
  }
  // Unified ability bonus from activeStatModifiers
  value += this.getAbilityBonus('initiative');
  return value;
}
```

BEFORE training getter (lines 522-535):
```typescript
get training(): number {
  let value = this.baseTraining;
  value += this.getEquipValue(this.weaponSlot, this.weaponSlotData, 'training');
  value += this.getEquipValue(this.armorSlot, this.armorSlotData, 'training');
  value += this.getEquipValue(this.accessorySlot, this.accessorySlotData, 'training');
  for (let idx = 0; idx < this.bandolierSlotsData.length; idx++) {
    value += this.getEquipValue(this.bandolierSlots[idx], this.bandolierSlotsData[idx], 'training');
  }
  if (this.combatantId === 'haarg') value += this.haargTrainingBonus || 0;
  if (this.combatantId === 'sarge') value += this.sargeTrainingBonus || 0;
  value += this.snakeSoloTrainingBonus || 0;
  value += this.tavistoWomanTrainingBonus || 0;
  return value;
}
```

AFTER training getter:
```typescript
get training(): number {
  let value = this.baseTraining;
  value += this.getEquipValue(this.weaponSlot, this.weaponSlotData, 'training');
  value += this.getEquipValue(this.armorSlot, this.armorSlotData, 'training');
  value += this.getEquipValue(this.accessorySlot, this.accessorySlotData, 'training');
  for (let idx = 0; idx < this.bandolierSlotsData.length; idx++) {
    value += this.getEquipValue(this.bandolierSlots[idx], this.bandolierSlotsData[idx], 'training');
  }
  // Unified ability bonus from activeStatModifiers
  value += this.getAbilityBonus('training');
  return value;
}
```

BEFORE combat getter (lines 537-556):
```typescript
get combat(): number {
  let value = this.baseCombat;
  value += this.getEquipValue(this.weaponSlot, this.weaponSlotData, 'combatBonus');
  value += this.getEquipValue(this.armorSlot, this.armorSlotData, 'combatBonus');
  value += this.getEquipValue(this.accessorySlot, this.accessorySlotData, 'combatBonus');
  for (let idx = 0; idx < this.bandolierSlotsData.length; idx++) {
    value += this.getEquipValue(this.bandolierSlots[idx], this.bandolierSlotsData[idx], 'combatBonus');
  }
  if (this.combatantId === 'haarg') value += this.haargCombatBonus || 0;
  if (this.combatantId === 'sarge') value += this.sargeCombatBonus || 0;
  value += this.boubaHandgunCombatBonus || 0;
  value += this.mayhemUziCombatBonus || 0;
  value += this.rozeskeArmorCombatBonus || 0;
  value += this.stumpyExplosiveCombatBonus || 0;
  value += this.vandradiMultiTargetCombatBonus || 0;
  value += this.dutchUnarmedCombatBonus || 0;
  value += this.snakeSoloCombatBonus || 0;
  value += this.tavistoWomanCombatBonus || 0;
  return Math.max(0, value);
}
```

AFTER combat getter:
```typescript
get combat(): number {
  let value = this.baseCombat;
  value += this.getEquipValue(this.weaponSlot, this.weaponSlotData, 'combatBonus');
  value += this.getEquipValue(this.armorSlot, this.armorSlotData, 'combatBonus');
  value += this.getEquipValue(this.accessorySlot, this.accessorySlotData, 'combatBonus');
  for (let idx = 0; idx < this.bandolierSlotsData.length; idx++) {
    value += this.getEquipValue(this.bandolierSlots[idx], this.bandolierSlotsData[idx], 'combatBonus');
  }
  // Unified ability bonus from activeStatModifiers
  value += this.getAbilityBonus('combat');
  return Math.max(0, value);
}
```

NOTE: Keep targets getter unchanged for now (uses moeSmawTargetBonus, raWeaponTargetBonus). This will be addressed in the UI display phase (Phase 39).
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors</verify>
  <done>initiative, training, and combat getters use getAbilityBonus() for unified calculation</done>
</task>

<task type="auto">
  <name>Task 3: Update game.ts to use unified updateAbilityBonuses</name>
  <files>src/rules/game.ts</files>
  <action>
Update `updateSquadBonuses()` in game.ts (lines 1207-1241) to use the unified `updateAbilityBonuses()` method instead of individual updateXBonus calls.

BEFORE (lines 1207-1241):
```typescript
/**
 * Update all squad-based bonuses (Sarge, Tack, Valkyrie, Snake, Tavisto) for a specific squad
 */
updateSquadBonuses(squad: Squad): void {
  if (!squad) return;
  const mercs = squad.getMercs();

  // Update Sarge's bonus
  const sarge = mercs.find(m => m.combatantId === 'sarge');
  if (sarge) {
    sarge.updateSargeBonus(mercs);
  }

  // Update Tack's squad bonus for ALL mercs in the squad
  // (Tack gives +2 initiative to everyone when she has highest initiative)
  for (const merc of mercs) {
    merc.updateTackSquadBonus(mercs);
  }

  // Update Valkyrie's squad bonus for ALL mercs in the squad
  // (Valkyrie gives +1 initiative to squad mates, not herself)
  for (const merc of mercs) {
    merc.updateValkyrieSquadBonus(mercs);
  }

  // Update Snake's solo bonus (when alone in squad)
  for (const merc of mercs) {
    merc.updateSnakeBonus(mercs);
  }

  // Update Tavisto's woman-in-squad bonus
  for (const merc of mercs) {
    merc.updateTavistoBonus(mercs);
  }
}
```

AFTER (unified):
```typescript
/**
 * Update all ability-based stat bonuses for a specific squad.
 * Uses unified updateAbilityBonuses() which reads from ability registry.
 * Handles: Sarge, Tack, Valkyrie, Snake, Tavisto, Haarg, and all equipment-conditional bonuses.
 */
updateSquadBonuses(squad: Squad): void {
  if (!squad) return;
  const mercs = squad.getMercs();

  // Single unified update for all ability bonuses
  // Each MERC's updateAbilityBonuses builds context and computes activeStatModifiers
  for (const merc of mercs) {
    merc.updateAbilityBonuses(mercs);
  }
}
```

Also update `updateHaargBonusForSquad()` (lines 1164-1170) to use the unified method:

BEFORE:
```typescript
updateHaargBonusForSquad(squad: Squad): void {
  const mercs = squad?.getMercs() ?? [];
  const haarg = mercs.find(m => m.combatantId === 'haarg');
  if (haarg) {
    haarg.updateHaargBonus(mercs);
  }
}
```

AFTER:
```typescript
/**
 * @deprecated Use updateSquadBonuses instead. Haarg is now handled by unified updateAbilityBonuses.
 */
updateHaargBonusForSquad(squad: Squad): void {
  // Delegate to unified method - updates all MERCs including Haarg
  this.updateSquadBonuses(squad);
}
```

Similarly update `updateAllHaargBonuses()` (lines 1140-1159):

BEFORE:
```typescript
updateAllHaargBonuses(): void {
  // Check all rebel squads
  for (const rebel of this.rebelPlayers) {
    if (rebel.primarySquad) {
      this.updateHaargBonusForSquad(rebel.primarySquad);
    }
    if (rebel.secondarySquad) {
      this.updateHaargBonusForSquad(rebel.secondarySquad);
    }
  }
  // Check dictator squads
  if (this.dictatorPlayer) {
    if (this.dictatorPlayer.primarySquad) {
      this.updateHaargBonusForSquad(this.dictatorPlayer.primarySquad);
    }
    if (this.dictatorPlayer.secondarySquad) {
      this.updateHaargBonusForSquad(this.dictatorPlayer.secondarySquad);
    }
  }
}
```

AFTER:
```typescript
/**
 * Update ability bonuses for all squads in the game.
 * @deprecated Individual methods like updateAllHaargBonuses are superseded by unified updateSquadBonuses.
 */
updateAllHaargBonuses(): void {
  // Update all rebel squads
  for (const rebel of this.rebelPlayers) {
    if (rebel.primarySquad) {
      this.updateSquadBonuses(rebel.primarySquad);
    }
    if (rebel.secondarySquad) {
      this.updateSquadBonuses(rebel.secondarySquad);
    }
  }
  // Update dictator squads
  if (this.dictatorPlayer) {
    if (this.dictatorPlayer.primarySquad) {
      this.updateSquadBonuses(this.dictatorPlayer.primarySquad);
    }
    if (this.dictatorPlayer.secondarySquad) {
      this.updateSquadBonuses(this.dictatorPlayer.secondarySquad);
    }
  }
}
```

The deprecated methods still work but now delegate to the unified system. This maintains backward compatibility with existing action code that calls `updateAllHaargBonuses()`.
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors; Run `npm test` - all tests should pass</verify>
  <done>game.ts updateSquadBonuses uses unified updateAbilityBonuses(), deprecated methods delegate to unified system</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `npx tsc --noEmit` compiles without errors
2. `npm test` passes all tests
3. Verify stat calculations manually:
   - Create a test with Mayhem + Uzi - combat should show +2 bonus
   - Create a test with Sarge as highest initiative - should get +1/+1/+1
   - Create a test with Tack as highest initiative - everyone gets +2 initiative
4. Check that old bonus fields are still populated (backward compat for combat.ts in Phase 40)
</verification>

<success_criteria>
- updateComputedStats() uses getAbilityBonus() for training, initiative, combat
- getEffectiveInitiative() uses getAbilityBonus() for initiative
- Stat getters (initiative, training, combat) use getAbilityBonus()
- game.ts updateSquadBonuses() calls merc.updateAbilityBonuses(mercs) for all MERCs
- Deprecated methods (updateHaargBonusForSquad, updateAllHaargBonuses) delegate to unified system
- All existing tests pass
- effectiveTraining, effectiveInitiative, effectiveCombat compute correctly
</success_criteria>

<output>
After completion, create `.planning/phases/38-unify-server-side-calculation/38-02-SUMMARY.md`
</output>
