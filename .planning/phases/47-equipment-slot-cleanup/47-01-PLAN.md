---
phase: 47-equipment-slot-cleanup
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/rules/elements.ts
  - tests/equipment-slots.test.ts
autonomous: true

must_haves:
  truths:
    - "When equip() replaces a bandolier with another accessory, displaced bandolier contents are returned to the caller"
    - "When equip() replaces a bandolier, no phantom bandolier slots remain on the combatant"
    - "equip() return type forces callers to handle displaced bandolier items (compiler enforced)"
    - "Gunther's equip() override also handles bandolier displacement when replacing the accessory slot"
  artifacts:
    - path: "src/rules/elements.ts"
      provides: "CombatantBase.equip() and CombatantModel.equip() with bandolier handling"
      contains: "displacedBandolierItems"
    - path: "tests/equipment-slots.test.ts"
      provides: "Tests for bandolier replacement and phantom slot removal"
      contains: "bandolier"
  key_links:
    - from: "CombatantBase.equip()"
      to: "clearBandolierSlots()"
      via: "called when replacing a bandolier accessory"
      pattern: "clearBandolierSlots"
    - from: "CombatantModel.equip()"
      to: "clearBandolierSlots()"
      via: "called in Gunther's accessory-replaces-accessory path"
      pattern: "clearBandolierSlots"
---

<objective>
Fix the core `equip()` method to handle bandolier replacement correctly, returning displaced bandolier contents alongside the replaced item.

Purpose: The root cause of both EQUIP-01 and EQUIP-02 is that `equip()` silently orphans bandolier slot contents when replacing a bandolier accessory. Fixing the core method with a richer return type makes the "pit of success" path the only path -- callers MUST handle displaced items because the compiler enforces it.

Output: Updated `equip()` methods in both `CombatantBase` and `CombatantModel`, plus tests proving the behavior.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/47-equipment-slot-cleanup/47-RESEARCH.md
@src/rules/elements.ts
@src/rules/equipment-effects.ts
@tests/equipment-effects.test.ts
</context>

<feature>
  <name>Bandolier-aware equip() return type</name>
  <files>src/rules/elements.ts, tests/equipment-slots.test.ts</files>
  <behavior>
    **Current behavior (broken):**
    - `equip()` returns `Equipment | undefined` (only the replaced item)
    - When replacing a bandolier accessory, items in bandolier slots are silently orphaned
    - After replacement, `bandolierSlots` getter still returns the orphaned items (phantom slots)

    **Expected behavior (fixed):**
    - `equip()` returns `{ replaced?: Equipment; displacedBandolierItems: Equipment[] }`
    - When replacing a bandolier accessory, `clearBandolierSlots()` is called first
    - Displaced bandolier items are returned in `displacedBandolierItems` array
    - After replacement, `bandolierSlots` returns empty array (no phantoms)
    - When NOT replacing a bandolier, `displacedBandolierItems` is empty array

    **Test cases:**
    1. Equip weapon (no bandolier involved) -> `{ replaced: oldWeapon, displacedBandolierItems: [] }`
    2. Equip accessory when no accessory slot -> `{ replaced: undefined, displacedBandolierItems: [] }`
    3. Equip accessory into bandolier slot (has space) -> `{ replaced: undefined, displacedBandolierItems: [] }`
    4. Replace bandolier (has 2 items in slots) with new accessory -> `{ replaced: bandolier, displacedBandolierItems: [item1, item2] }`
    5. Replace non-bandolier accessory with new accessory -> `{ replaced: oldAccessory, displacedBandolierItems: [] }`
    6. After replacing bandolier, `combatant.bandolierSlots` is empty
    7. After replacing bandolier, `combatant.getMaxBandolierSlots()` is 0
    8. Gunther: replace bandolier in accessory slot when weapon/armor also full -> displaced items returned
  </behavior>
  <implementation>
    **Step 1 - Define the return type (elements.ts):**
    Add an interface or type alias near the top of the combatant section:
    ```typescript
    interface EquipResult {
      replaced?: Equipment;
      displacedBandolierItems: Equipment[];
    }
    ```

    **Step 2 - Fix CombatantBase.equip() (elements.ts ~line 892):**
    Change return type from `Equipment | undefined` to `EquipResult`.
    In the `case 'Accessory':` block's else branch (line 910-912), BEFORE clearing the accessory slot, check if the current accessory provides bandolier slots using `this.getMaxBandolierSlots() > 0`. If so, call `this.clearBandolierSlots()` and capture the result.

    Key detail: `clearBandolierSlots()` calls `syncEquipmentData()` and `updateComputedStats()` internally, but `equip()` also calls them at the end (line 916-917). This double-call is harmless but worth noting. Do NOT remove the calls at the end of equip() -- they cover all branches.

    ```typescript
    equip(equipment: Equipment): EquipResult {
      let replaced: Equipment | undefined;
      let displacedBandolierItems: Equipment[] = [];

      switch (equipment.equipmentType) {
        case 'Weapon':
          replaced = this.clearSlot(this.weaponSlot);
          this.equipToSlot(equipment, 'weapon');
          break;
        case 'Armor':
          replaced = this.clearSlot(this.armorSlot);
          this.equipToSlot(equipment, 'armor');
          break;
        case 'Accessory':
          if (!this.accessorySlot) {
            this.equipToSlot(equipment, 'accessory');
          } else if (this.getAvailableBandolierSlots() > 0) {
            const idx = this.getNextBandolierIndex();
            this.equipToSlot(equipment, `bandolier:${idx}`);
          } else {
            // Clear bandolier contents BEFORE replacing the accessory
            if (this.getMaxBandolierSlots() > 0) {
              displacedBandolierItems = this.clearBandolierSlots();
            }
            replaced = this.clearSlot(this.accessorySlot);
            this.equipToSlot(equipment, 'accessory');
          }
          break;
      }
      this.syncEquipmentData();
      this.updateComputedStats();
      return { replaced, displacedBandolierItems };
    }
    ```

    **Step 3 - Fix CombatantModel.equip() override (elements.ts ~line 1030):**
    Same return type change. The Gunther path (line 1034-1050) has its own accessory replacement in the final else branch (line 1044-1046) that replaces the accessory slot. Add bandolier clearing there too.

    ```typescript
    override equip(equipment: Equipment): EquipResult {
      let replaced: Equipment | undefined;
      let displacedBandolierItems: Equipment[] = [];

      // MERC-42g: Gunther can equip accessories in any slot
      if (this.combatantId === 'gunther' && equipment.equipmentType === 'Accessory') {
        if (!this.accessorySlot) {
          this.equipToSlot(equipment, 'accessory');
        } else if (this.getAvailableBandolierSlots() > 0) {
          const idx = this.getNextBandolierIndex();
          this.equipToSlot(equipment, `bandolier:${idx}`);
        } else if (!this.weaponSlot) {
          this.equipToSlot(equipment, 'weapon');
        } else if (!this.armorSlot) {
          this.equipToSlot(equipment, 'armor');
        } else {
          // Clear bandolier contents BEFORE replacing the accessory
          if (this.getMaxBandolierSlots() > 0) {
            displacedBandolierItems = this.clearBandolierSlots();
          }
          replaced = this.clearSlot(this.accessorySlot);
          this.equipToSlot(equipment, 'accessory');
        }
        this.syncEquipmentData();
        this.updateComputedStats();
        return { replaced, displacedBandolierItems };
      }

      // MERC-vwi: Genesis can equip weapons in accessory slot
      if (this.combatantId === 'genesis' && equipment.equipmentType === 'Weapon') {
        if (!this.weaponSlot) {
          this.equipToSlot(equipment, 'weapon');
        } else if (!this.accessorySlot) {
          this.equipToSlot(equipment, 'accessory');
        } else {
          replaced = this.clearSlot(this.weaponSlot);
          this.equipToSlot(equipment, 'weapon');
        }
        this.syncEquipmentData();
        this.updateComputedStats();
        return { replaced, displacedBandolierItems };
      }

      return super.equip(equipment);
    }
    ```

    **Important notes:**
    - Do NOT change `clearBandolierSlots()` itself -- it already works correctly
    - Do NOT change `unequip()` -- it handles a different flow (explicit drop, not replacement)
    - The `dropEquipment` action in rebel-equipment.ts already handles bandolier correctly via `unequip()` + manual `clearBandolierSlots()` -- that code continues to work as-is
    - Export the `EquipResult` type so callers can import it
  </implementation>
</feature>

<verification>
- `npx vitest run tests/equipment-slots.test.ts` -- all new bandolier tests pass
- `npx tsc --noEmit` -- TypeScript compilation fails on all callers that haven't been updated yet (this is EXPECTED and CORRECT -- the compiler is now enforcing the pit of success)
- Verify `bandolierSlots` returns empty array after replacement in tests
- Verify `getMaxBandolierSlots()` returns 0 after replacement in tests
</verification>

<success_criteria>
- `equip()` returns `EquipResult` with both `replaced` and `displacedBandolierItems`
- Tests prove: replacing a bandolier returns displaced items and clears phantom slots
- Tests prove: non-bandolier equip operations return empty `displacedBandolierItems`
- TypeScript compilation catches all callers that need updating (expected to fail until Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/47-equipment-slot-cleanup/47-01-SUMMARY.md`
</output>
