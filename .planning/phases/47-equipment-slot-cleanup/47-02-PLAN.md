---
phase: 47-equipment-slot-cleanup
plan: 02
type: execute
wave: 2
depends_on: ["47-01"]
files_modified:
  - src/rules/actions/rebel-equipment.ts
  - src/rules/actions/rebel-economy.ts
  - src/rules/actions/day-one-actions.ts
  - src/rules/actions/helpers.ts
  - src/rules/actions/dictator-actions.ts
  - src/rules/day-one.ts
  - src/rules/dictator-abilities.ts
  - src/rules/tactics-effects.ts
  - src/rules/ai-helpers.ts
autonomous: true

must_haves:
  truths:
    - "Every call site of equip() handles the new EquipResult return type"
    - "Displaced bandolier items are routed to the correct destination at each call site"
    - "TypeScript compiles cleanly with no errors"
    - "All existing tests pass with no regressions"
  artifacts:
    - path: "src/rules/actions/rebel-equipment.ts"
      provides: "Updated reEquip, reEquipContinue, feedbackDiscard, hagnessGiveEquipment, squidheadDisarm"
      contains: "displacedBandolierItems"
    - path: "src/rules/actions/rebel-economy.ts"
      provides: "Updated collectEquipment, equipFromStash, buyAndEquip"
      contains: "displacedBandolierItems"
    - path: "src/rules/ai-helpers.ts"
      provides: "Updated AI equip logic"
      contains: "displacedBandolierItems"
  key_links:
    - from: "rebel-equipment.ts callers"
      to: "sector.addToStash() or discard.putInto()"
      via: "routing displaced bandolier items"
      pattern: "displacedBandolierItems"
    - from: "ai-helpers.ts"
      to: "sector.addToStash()"
      via: "routing displaced bandolier items for AI"
      pattern: "displacedBandolierItems"
---

<objective>
Update every caller of `equip()` across the codebase to handle the new `EquipResult` return type and route displaced bandolier items to the correct destination.

Purpose: The core `equip()` method now returns `{ replaced?, displacedBandolierItems[] }` (from Plan 01). TypeScript will refuse to compile until all callers are updated. Each caller must destructure the result and route displaced items appropriately based on its context (sector stash, discard pile, etc.).

Output: All call sites updated, TypeScript compiles cleanly, all tests pass.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/47-equipment-slot-cleanup/47-RESEARCH.md
@.planning/phases/47-equipment-slot-cleanup/47-01-SUMMARY.md
@src/rules/elements.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update all equip() callers to handle EquipResult</name>
  <files>
    src/rules/actions/rebel-equipment.ts
    src/rules/actions/rebel-economy.ts
    src/rules/actions/day-one-actions.ts
    src/rules/actions/helpers.ts
    src/rules/actions/dictator-actions.ts
    src/rules/day-one.ts
    src/rules/dictator-abilities.ts
    src/rules/tactics-effects.ts
    src/rules/ai-helpers.ts
  </files>
  <action>
    Find every call to `.equip(` in the codebase using grep. For each call site, destructure the return value and handle `displacedBandolierItems`. The routing destination depends on what context each caller has:

    **Call sites with sector access (route displaced items to sector stash):**

    1. `rebel-equipment.ts` - `reEquip` (~line 219): Has `sector`. Destructure result. After handling `replaced` (already adds to stash), loop over `displacedBandolierItems` and call `sector.addToStash(item)` for each. For damaged items, use `game.getEquipmentDiscard(item.equipmentType)` to route to discard.

    2. `rebel-equipment.ts` - `reEquipContinue` (~line 358): Same pattern as reEquip. Has `sector`.

    3. `rebel-equipment.ts` - `squidheadDisarm` (~line 771): Has `sector`. Unlikely to trigger (mine is not a bandolier replacement) but handle defensively with same stash pattern.

    4. `rebel-economy.ts` - `collectEquipment` (~line 515): Has `sector`. Same stash routing pattern.

    5. `rebel-economy.ts` - `equipFromStash` (~line 656): Has `sector`. Same stash routing pattern.

    6. `rebel-economy.ts` - `buyAndEquip` (~line 1155): Has `sector`. Same stash routing pattern.

    7. `ai-helpers.ts` (~line 545): Has `sector`. Same stash routing pattern.

    **Call sites without sector access (route displaced items to discard pile):**

    8. `rebel-equipment.ts` - `feedbackDiscard` (~line 710): No sector context -- Feedback retrieves from discard. Route displaced bandolier items to discard using `game.getEquipmentDiscard(item.equipmentType)` and `item.putInto(discard)`.

    9. `rebel-equipment.ts` - `hagnessGiveEquipment` (~line 1101): Hagness draws from deck. Route displaced items to discard using same pattern as feedbackDiscard.

    **Call sites during initial equip (displaced items unlikely but handle defensively):**

    10. `day-one-actions.ts` (~line 706): Initial merc equipment draw. No sector context. Route any displaced items to discard. This is defensive -- during day one, mercs start empty so bandolier replacement is extremely unlikely.

    11. `day-one-actions.ts` (~line 764): Dictator equipment draw. Same defensive handling.

    12. `day-one.ts` (~line 140 and ~line 173): Vrbansk bonus accessory and free equipment draw. Has sector via landing context. Route to sector stash if available, otherwise discard.

    13. `helpers.ts` (~line 459 and ~line 492): equipMercForLanding helper. Has sector context via squad's landing sector. Route to stash.

    14. `dictator-actions.ts` (~line 197): Dictator re-equip from draw. No sector. Route to discard.

    15. `dictator-abilities.ts` (~line 76): Dictator ability equipment draw. No sector. Route to discard.

    16. `tactics-effects.ts` (~line 212): Tactics card equipment draw. No sector. Route to discard.

    **Pattern for updating each call site:**

    Where caller currently does:
    ```typescript
    const replaced = unit.equip(equipment);
    if (replaced) {
      sector.addToStash(replaced);
    }
    ```

    Change to:
    ```typescript
    const { replaced, displacedBandolierItems } = unit.equip(equipment);
    if (replaced) {
      sector.addToStash(replaced);
    }
    for (const item of displacedBandolierItems) {
      sector.addToStash(item);
    }
    ```

    For discard-routed callers:
    ```typescript
    const { replaced, displacedBandolierItems } = unit.equip(equipment);
    if (replaced) {
      const discard = game.getEquipmentDiscard(replaced.equipmentType);
      if (discard) replaced.putInto(discard);
    }
    for (const item of displacedBandolierItems) {
      const discard = game.getEquipmentDiscard(item.equipmentType);
      if (discard) item.putInto(discard);
    }
    ```

    For callers that currently ignore the return value (just `unit.equip(equipment)` with no assignment):
    ```typescript
    const { displacedBandolierItems } = unit.equip(equipment);
    for (const item of displacedBandolierItems) {
      // Route appropriately based on context
    }
    ```

    **Important:** Do NOT import `EquipResult` type at caller sites unless needed for explicit type annotations. Destructuring handles the typing automatically. Only import it if a caller needs to store the result in a typed variable.

    **Also important:** Check the game messages. If a caller logs "returned X to stash", make sure to also log displaced bandolier items being returned. Example: after the existing replaced message, add something like:
    ```typescript
    if (displacedBandolierItems.length > 0) {
      const names = displacedBandolierItems.map(e => e.equipmentName).join(', ');
      game.message(`Bandolier contents returned: ${names}`);
    }
    ```
  </action>
  <verify>
    Run `npx tsc --noEmit` -- must compile cleanly with zero errors.
    Run `npx vitest run` -- all existing tests plus new bandolier tests must pass.
  </verify>
  <done>
    - Every `.equip(` call site destructures `EquipResult`
    - Displaced bandolier items routed to sector stash (when sector available) or discard pile (when no sector)
    - TypeScript compiles with zero errors
    - All tests pass (no regressions)
    - Game messages inform the player when bandolier contents are displaced
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles cleanly
2. `npx vitest run` -- all tests pass
3. Grep for `.equip(` across `src/rules/` -- every call site destructures `{ replaced, displacedBandolierItems }` or at minimum `{ displacedBandolierItems }`
4. No orphaned bandolier items possible at any call site
</verification>

<success_criteria>
- Zero TypeScript compilation errors
- All existing tests pass (no regressions)
- New bandolier tests from Plan 01 continue to pass
- Every equip() call site handles displaced bandolier items
- Displaced items routed correctly: sector stash when available, discard pile otherwise
- EQUIP-01 satisfied: replacing bandolier drops contents to stash
- EQUIP-02 satisfied: no phantom bandolier slots after replacement
</success_criteria>

<output>
After completion, create `.planning/phases/47-equipment-slot-cleanup/47-02-SUMMARY.md`
</output>
