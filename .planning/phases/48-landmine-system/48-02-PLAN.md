---
phase: 48-landmine-system
plan: 02
type: execute
wave: 2
depends_on: ["48-01"]
files_modified:
  - src/rules/actions/rebel-movement.ts
  - src/rules/combat.ts
autonomous: true

must_haves:
  truths:
    - "When an enemy squad enters a sector containing a landmine in the stash, the landmine detonates"
    - "Landmine check fires BEFORE hasEnemies() check so dead units don't trigger combat"
    - "All three movement actions (move, coordinatedAttack, executeCoordinatedAttack) trigger landmine check"
    - "The old detonateLandMines() call in combat.ts is removed"
    - "Existing movement behavior is unchanged when no mines are present"
  artifacts:
    - path: "src/rules/actions/rebel-movement.ts"
      provides: "Landmine check wired into all 3 movement actions"
      contains: "checkLandMines"
    - path: "src/rules/combat.ts"
      provides: "Old detonateLandMines call removed"
  key_links:
    - from: "src/rules/actions/rebel-movement.ts"
      to: "src/rules/landmine.ts"
      via: "checkLandMines() import and call"
      pattern: "import.*checkLandMines.*from.*landmine"
    - from: "src/rules/actions/rebel-movement.ts"
      to: "src/rules/combat.ts"
      via: "hasEnemies() called AFTER checkLandMines()"
      pattern: "checkLandMines.*hasEnemies"
---

<objective>
Wire `checkLandMines()` into all three movement actions and remove the old `detonateLandMines()` call from combat.ts.

Purpose: This connects the core landmine logic (from Plan 01) to the actual movement entry points, completing requirements MINE-01 through MINE-04. The key timing constraint is: landmine check must happen AFTER `squad.sectorId = destination.sectorId` (so units are "in" the sector) but BEFORE `hasEnemies()` (so dead units from mine damage don't trigger combat).

Output: All three movement actions call `checkLandMines()`, old combat.ts call removed.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/48-landmine-system/48-RESEARCH.md
@.planning/phases/48-landmine-system/48-01-SUMMARY.md

@src/rules/actions/rebel-movement.ts
@src/rules/landmine.ts (created in Plan 01)
@src/rules/combat.ts (lines 1-30 for imports, line 2502 for detonateLandMines call)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire checkLandMines into all movement actions</name>
  <files>src/rules/actions/rebel-movement.ts</files>
  <action>
    Add `import { checkLandMines } from '../landmine.js';` to rebel-movement.ts.

    **Move action (line ~242):** Insert `checkLandMines()` call AFTER `squad.sectorId = destination.sectorId` (line 242) and the dictator combatant move block (lines 244-252), but BEFORE the `hasEnemies()` check block (lines 257-288).

    The insertion point is between the "moved MERCs to sector" message (line 255) and the "Combat triggers when" comment (line 257).

    ```typescript
    // Check for landmines in the destination sector
    const isRebel = game.isRebelPlayer(ctx.player);
    checkLandMines(game, destination, [squad], isRebel);
    ```

    Note: `isRebel` is already computed earlier in the move action's execute handler (around line 204 in the condition checks). Check if it's available in the execute scope. If not, compute it. The `game.isRebelPlayer(ctx.player)` call is the way to determine this.

    **Coordinated Attack action (lines 368-382):** Insert after both squads have moved (line 370: `player.secondarySquad.sectorId = target.sectorId`) but BEFORE `hasEnemies()` check (line 376).

    ```typescript
    // Check for landmines (both squads entering together)
    checkLandMines(game, target, [player.primarySquad, player.secondarySquad], true);
    ```

    The `true` is hardcoded because coordinated attack is rebel-only (see condition on line 303).

    **Execute Coordinated Attack action (lines 614-631):** Insert after all squads have moved (the for-loop ending around line 617) and after `game.clearCoordinatedAttack(targetId)` (line 620) but BEFORE `hasEnemies()` check (line 626).

    Collect all participating squads into an array, then call:
    ```typescript
    // Collect squads that moved
    const enteringSquads: Squad[] = [];
    for (const { playerId, squadType } of participants) {
      const rebel = game.rebelPlayers.find(p => `${p.seat}` === playerId);
      if (!rebel) continue;
      enteringSquads.push(squadType === 'primary' ? rebel.primarySquad : rebel.secondarySquad);
    }

    // Check for landmines
    checkLandMines(game, target, enteringSquads, true);
    ```

    Note: You need to preserve access to `participants` after `clearCoordinatedAttack` -- read the participants BEFORE clearing, or restructure so the squad collection happens before the clear. Look at the actual code flow carefully. The existing code already has `participants` captured before the for-loop, so it should still be accessible.

    Also add `Squad` to the imports from `'../elements.js'` if it is not already imported (check existing imports -- it likely already is since the file uses Squad).
  </action>
  <verify>
    `npx tsc --noEmit` passes. Search for `checkLandMines` in rebel-movement.ts -- should appear 3 times (one per movement action) plus the import.
  </verify>
  <done>All three movement actions (move, coordinatedAttack, executeCoordinatedAttack) call checkLandMines() at the correct position: after squad relocation, before hasEnemies() check.</done>
</task>

<task type="auto">
  <name>Task 2: Remove old detonateLandMines call from combat.ts</name>
  <files>src/rules/combat.ts</files>
  <action>
    1. Remove the `detonateLandMines` call at line 2502:
       ```typescript
       // MERC-b65: AI detonates land mines before combat begins
       detonateLandMines(game, sector, { name: attackingPlayer.name ?? 'Unknown' });
       ```
       Remove both the comment line and the function call line.

    2. Remove `detonateLandMines` from the import statement at the top of combat.ts (line 23):
       ```typescript
       import {
         sortTargetsByAIPriority,
         detonateLandMines,  // <-- remove this line
         shouldUseEpinephrine,
         hasEpinephrineShot,
       } from './ai-helpers.js';
       ```

    3. Verify that `detonateLandMines` is not called anywhere else in combat.ts. If there are other call sites, remove those too.

    Do NOT remove the `detonateLandMines` function from `ai-combat-helpers.ts` or its re-export from `ai-helpers.ts` -- it may still be useful as a reference or for other consumers. Only remove the call site in combat.ts.
  </action>
  <verify>
    `npx tsc --noEmit` passes. `grep -n "detonateLandMines" src/rules/combat.ts` returns no results. `npm test` passes (no regressions).
  </verify>
  <done>The old detonateLandMines() call in combat.ts is completely removed. No double-detonation is possible. All mine detonation now happens at the movement level via checkLandMines().</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` -- no type errors across codebase
- `npm test` -- all existing tests pass (no regressions)
- `npm test -- tests/landmine.test.ts` -- landmine-specific tests pass
- `grep -rn "checkLandMines" src/rules/actions/rebel-movement.ts` shows 3 call sites + 1 import
- `grep -n "detonateLandMines" src/rules/combat.ts` returns empty (removed)
- The call order in each movement action is: squad.sectorId = destination -> checkLandMines() -> hasEnemies()
</verification>

<success_criteria>
- All 3 movement actions call checkLandMines() between squad relocation and hasEnemies() check
- detonateLandMines() call removed from combat.ts line 2502
- detonateLandMines import removed from combat.ts
- All existing tests pass (no regressions)
- TypeScript compiles clean
</success_criteria>

<output>
After completion, create `.planning/phases/48-landmine-system/48-02-SUMMARY.md`
</output>
