---
phase: 32
plan: 04
wave: 3
depends_on: [32-01, 32-02, 32-03]
files_modified:
  - src/ui/composables/useActionState.ts (new)
autonomous: true
---

# Plan 04: Create useActionState Composable

## Objective

Extract action-related state derivation from GameBoard.vue into `src/ui/composables/useActionState.ts`. This composable provides action type flags, selection state, and derived action data.

## Context

**Source:** GameBoard.vue lines 1132-1665

**Requirement:** STATE-04 - actionChoices, currentSelection, currentActionMetadata, action type flags, selection handlers

**Dependencies:** Uses sectors from STATE-02, squads from STATE-03

**Note:** This is the most complex composable with watch handlers and async logic.

## Tasks

<task id="1">
Read GameBoard.vue to locate the exact code for:

**Core state:**
- `actionChoices` computed (line ~1132)
- `currentActionMetadata` computed (lines ~1558-1583)
- `currentSelection` computed (lines ~1587-1604)
- `allSelectionsComplete` computed (lines ~1607-1617)
- `getCurrentActionName` function (lines ~1620-1632)

**Action type flags (computed booleans):**
- `isHiringMercs` (lines ~1137-1150)
- `isSelectingDictator` (lines ~1153-1157)
- `isHagnessDrawActive` (lines ~1160-1162)
- `isPlacingLanding` (lines ~1198-1200)
- `isSelectingRetreatSector` (lines ~1203-1207)
- `isEquipping` (lines ~1257-1259)
- `isSelectingEquipmentType` (lines ~1262-1265)
- `isCastroHiring` (lines ~1268-1270)
- `isSelectingSector` (lines ~1273-1276)
- `showAssignToSquad` (lines ~1396-1422)
- `isHagnessSelectingType` (lines ~1424-1432)
- `isHagnessSelectingRecipient` (lines ~1450-1460)

**Derived state:**
- `retreatSectorChoices` (lines ~1210-1235)
- `sectorChoices` (lines ~1279+)
- `landingZoneMetadata` (lines ~1251-1254)
- `selectedMercForEquipment` (lines ~1338-1375)
- Hagness-specific states (lines ~1424-1515)

**Refs:**
- `deferredChoicesLoading` ref
- `fetchedDeferredChoices` reactive
- `showHiringMercModal` ref
- `assignToSquadDelayedHide` ref
</task>

<task id="2">
Create `src/ui/composables/useActionState.ts` with this structure:

```typescript
import { computed, ref, reactive, watch, type ComputedRef, type Ref } from 'vue';
import type { Sector } from './useSectorState';
import type { SquadState } from './useSquadState';

export interface ActionStateProps {
  availableActions: string[];
  actionController: any;
  actionArgs: Record<string, any>;
  state?: { state?: { actionMetadata?: any[] } };
}

export interface ActionStateReturn {
  // Core state
  actionChoices: ComputedRef<Record<string, any>>;
  currentActionMetadata: ComputedRef<any>;
  currentSelection: ComputedRef<any>;
  allSelectionsComplete: ComputedRef<boolean>;
  getCurrentActionName: () => string;

  // Action type flags
  isHiringMercs: ComputedRef<boolean>;
  isSelectingDictator: ComputedRef<boolean>;
  isHagnessDrawActive: ComputedRef<boolean>;
  isPlacingLanding: ComputedRef<boolean>;
  isSelectingRetreatSector: ComputedRef<boolean>;
  isEquipping: ComputedRef<boolean>;
  isSelectingEquipmentType: ComputedRef<boolean>;
  isCastroHiring: ComputedRef<boolean>;
  isSelectingSector: ComputedRef<boolean>;
  showAssignToSquad: ComputedRef<boolean>;
  isHagnessSelectingType: ComputedRef<boolean>;
  isHagnessSelectingRecipient: ComputedRef<boolean>;

  // Derived state
  retreatSectorChoices: ComputedRef<Sector[]>;
  sectorChoices: ComputedRef<Sector[]>;
  landingZoneMetadata: ComputedRef<any>;
  selectedMercForEquipment: ComputedRef<any>;

  // Hagness state
  hagnessEquipmentTypeChoices: ComputedRef<any[]>;
  hagnessEquipmentTypeSelection: ComputedRef<string | null>;
  hagnessDrawnEquipmentToAssign: ComputedRef<any>;
  hagnessRecipientChoices: ComputedRef<any[]>;

  // Loading/UI state
  deferredChoicesLoading: Ref<boolean>;
  fetchedDeferredChoices: Record<string, any[]>;
  showHiringMercModal: Ref<boolean>;
  assignToSquadDelayedHide: Ref<boolean>;
}

export function useActionState(
  props: ActionStateProps,
  sectors: ComputedRef<Sector[]>,
  primarySquad: ComputedRef<SquadState | null>,
  secondarySquad: ComputedRef<SquadState | null>,
  fetchDeferredChoicesFn?: (actionName: string, selectionName: string) => Promise<any[]>
): ActionStateReturn {

  // Refs for UI state
  const deferredChoicesLoading = ref(false);
  const fetchedDeferredChoices = reactive<Record<string, any[]>>({});
  const showHiringMercModal = ref(false);
  const assignToSquadDelayedHide = ref(false);

  // Core action state computeds
  const actionChoices = computed(() => ({ ...props.actionArgs }));

  const currentActionMetadata = computed(() => {
    // ... from GameBoard.vue
  });

  // ... all other computeds and functions

  // Watch handlers (keep in composable)
  // Note: May need to move some watches to GameBoard.vue if they interact with emit

  return {
    // ... all returns
  };
}
```
</task>

<task id="3">
Extract exact logic from GameBoard.vue. Key patterns to preserve:

**Action type flag pattern:**
```typescript
const isHiringMercs = computed(() => {
  return props.availableActions.includes('hireMerc') ||
         props.actionController.currentAction.value === 'hireMerc';
});
```

**Deferred choices cache pattern:**
```typescript
const fetchedDeferredChoices = reactive<Record<string, any[]>>({});
// Key format: `${actionName}:${selectionName}`
```

**currentSelection derivation:**
- Find first unfilled selection from metadata
- Check if already filled in actionArgs
</task>

<task id="4">
Decide which watch handlers stay in composable vs GameBoard.vue:
- Watchers that only update composable state → stay in composable
- Watchers that call action methods or emit → may need to stay in GameBoard.vue or be passed callbacks
</task>

<task id="5">
Verify TypeScript compiles without errors:
```bash
npx tsc --noEmit
```
</task>

## Verification

<verify>
1. File exists at src/ui/composables/useActionState.ts
2. TypeScript compiles without errors
3. Exports: useActionState function
4. Returns all action-related computed refs and UI state refs
5. Correctly derives current selection from metadata
6. Preserves deferred choices caching pattern
</verify>

## Must Haves

- [ ] All action type flags computed correctly (isHiringMercs, isSelectingDictator, etc.)
- [ ] `currentActionMetadata` finds metadata from props.state
- [ ] `currentSelection` derives first unfilled selection
- [ ] `allSelectionsComplete` returns true when all selections filled
- [ ] Deferred choices cached in reactive object by key
- [ ] `retreatSectorChoices` enriches sector data for retreat selection
- [ ] `sectorChoices` enriches sector data for general selection
- [ ] Hagness-specific states computed correctly
- [ ] Loading state refs exposed for UI feedback
- [ ] TypeScript types exported for ActionStateProps and ActionStateReturn
