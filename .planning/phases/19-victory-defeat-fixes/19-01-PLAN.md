---
phase: 19-victory-defeat-fixes
plan: 01
type: execute
---

<objective>
Fix victory and defeat condition semantics for dictator defeat status.

Purpose: Make the `isDefeated` property accurately represent "dictator has lost" (dead OR base captured), improving API clarity and ensuring consistent game state reporting.
Output: Updated `isDefeated` logic and comprehensive tests for victory/defeat conditions.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-data-consistency/18-01-SUMMARY.md

# Key files:
@src/rules/game.ts

# Rules reference:
@data/rules/11-victory-and-game-end.md

**Constraining decisions:**
- Phase 18: Data consistency complete, ready for Phase 19

**Current implementation analysis:**
- `isDefeated` (line 283): Only checks `baseRevealed && dictator?.isDead === true`
- `isBaseCaptured()` (line 1424): Checks if rebels control base sector
- Both conditions are checked separately in `isFinished()` and `getWinners()`
- The issue: `isDefeated` semantically means "dictator has lost" but only covers one loss condition

**Rules doc game end conditions:**
1. Tactics Exhausted - Dictator has no cards → point comparison
2. Base Captured - Rebels control dictator's base → Rebels win immediately
3. Dictator Killed - Dictator card health = 0 → Rebels win immediately

**Fix needed:**
- `isDefeated` should return true if dictator is dead OR base is captured
- This makes the property semantically correct ("has the dictator been defeated?")
- The `isFinished()` and `getWinners()` logic can then be simplified

**Rebel defeat:**
- Current `allRebelUnitsEliminated()` correctly checks for Day 2+ and no MERCs + no militia
- Rules doc edge case "All Rebels' MERCs Die" refers to MERCs only, not all units
- Current implementation is correct per project requirements
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update isDefeated to include base capture</name>
  <files>src/rules/game.ts</files>
  <action>
Update the `isDefeated` getter in `MERCPlayer` class (around line 281-284) to return true if EITHER:
1. Base is revealed AND dictator card is dead (current condition)
2. Base is captured by rebels (use `isBaseCaptured()` call on the game instance)

The challenge: `isDefeated` is on MERCPlayer, but `isBaseCaptured()` is on MERCGame. We need to access the game from the player.

**Approach:** Since MERCPlayer already has access patterns through the game, and `isDefeated` is only meaningful for the dictator player, update the getter to check both conditions. The MERCPlayer can access its parent game through `this.game`.

Update the getter to:
```typescript
get isDefeated(): boolean {
  if (!this.isDictator()) return false;
  // Dictator is defeated if dead OR base is captured
  return (this.baseRevealed && this.dictator?.isDead === true) ||
         (this.game as MERCGame).isBaseCaptured();
}
```

Then simplify `isFinished()` and `getWinners()` to remove redundant `isBaseCaptured()` checks since they're now covered by `isDefeated`.

**What to avoid:** Don't change the semantics of when the game ends - the same conditions should trigger game end, just consolidated under `isDefeated`.
  </action>
  <verify>
- `npm run build` passes
- `npm test` passes (no regressions)
- Verify `isDefeated` returns true for both dictator death and base capture scenarios
  </verify>
  <done>
- `isDefeated` returns true for dictator dead OR base captured
- `isFinished()` and `getWinners()` simplified to use `isDefeated` only
- Build passes, tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add victory/defeat condition tests</name>
  <files>tests/victory-defeat.test.ts</files>
  <action>
Create a new test file for victory/defeat conditions. Test:

1. **Dictator defeat by death:**
   - Setup: Base revealed, dictator at 0 health
   - Assert: `dictatorPlayer.isDefeated` is true
   - Assert: `game.isFinished()` is true
   - Assert: `game.getWinners()` returns rebel players

2. **Dictator defeat by base capture:**
   - Setup: Base revealed, no dictator units in base sector, rebel units present
   - Assert: `dictatorPlayer.isDefeated` is true
   - Assert: `game.isFinished()` is true
   - Assert: `game.getWinners()` returns rebel players

3. **Rebel defeat by unit elimination:**
   - Setup: Day 2+, all rebel MERCs dead, no rebel militia
   - Assert: `game.allRebelUnitsEliminated()` is true
   - Assert: `game.isFinished()` is true
   - Assert: `game.getWinners()` returns dictator player

4. **No rebel defeat on Day 1:**
   - Setup: Day 1, no rebel units (during setup)
   - Assert: `game.allRebelUnitsEliminated()` is false
   - Assert: `game.isFinished()` is false

5. **Dictator not defeated if base not captured:**
   - Setup: Base revealed, dictator units still in base, dictator alive
   - Assert: `dictatorPlayer.isDefeated` is false

Use the existing test setup patterns from other test files. Place in `tests/` directory following project convention.
  </action>
  <verify>
- `npm test -- tests/victory-defeat.test.ts` passes
- All 5+ test cases pass
  </verify>
  <done>
- Test file created with comprehensive victory/defeat tests
- All tests pass
- Coverage for dictator death, base capture, rebel elimination, Day 1 guard
  </done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm test` passes all tests including new victory-defeat tests
- [ ] `isDefeated` returns true for dictator dead OR base captured
- [ ] `isFinished()` and `getWinners()` still work correctly for all game end conditions
</verification>

<success_criteria>

- `isDefeated` semantically correct (dead OR base captured)
- Game end logic unchanged (same conditions trigger end)
- New tests verify all victory/defeat conditions
- No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/19-victory-defeat-fixes/19-01-SUMMARY.md`
</output>
