---
phase: 08-artillery-barrage
plan: 03
type: execute
---

<objective>
Modify Artillery Barrage to set pending state instead of auto-applying damage.

Purpose: Change the artillery barrage effect to pause for rebel input when there are units to allocate hits to.
Output: Modified artilleryBarrage function that sets pendingArtilleryAllocation state and handles multi-sector allocation flow.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./08-03-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-artillery-barrage/08-01-SUMMARY.md
@.planning/phases/08-artillery-barrage/08-02-SUMMARY.md
@src/rules/tactics-effects.ts
@src/rules/game.ts

**Current Artillery Barrage behavior (lines 39-98):**
1. Find sectors adjacent to dictator-controlled sectors that have rebels
2. Attack up to rebelCount sectors
3. For each sector: roll d6, auto-apply damage (militia first, then MERCs)
4. Return result

**New behavior needed:**
1. Find sectors and roll dice (same as before)
2. For FIRST sector: set pendingArtilleryAllocation with valid targets and hits
3. Include remaining sectors in `sectorsRemaining` queue
4. Return early with `success: true` and indication that allocation is pending
5. After rebel allocates hits for current sector, continue to next sector in queue
6. When queue empty, clear pending state

**Multi-sector handling:**
Artillery can hit multiple sectors. Each sector needs its own allocation.
Use `sectorsRemaining` array to queue up sectors, process one at a time.

**Target identification:**
For each sector, valid targets are:
- Rebel militia in that sector (use sector.getRebelMilitia(playerId))
- MERCs in that sector (use game.getMercsInSector(sector, rebel))
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor artilleryBarrage to set pending state for first sector</name>
  <files>src/rules/tactics-effects.ts</files>
  <action>
Rewrite the artilleryBarrage function to:

1. Keep the sector finding logic (lines 40-58)
2. Roll dice for ALL sectors upfront and store results
3. Build the sectors queue with rolled hits
4. If no sectors to attack, return early (no change)
5. If sectors have units to damage, set pendingArtilleryAllocation for first sector
6. Return with `success: true, message: 'Artillery barrage initiated'`

New structure:
```typescript
function artilleryBarrage(game: MERCGame): TacticsEffectResult {
  // Find sectors (existing logic)
  const dictatorSectors = game.gameMap.getAllSectors().filter(s => s.dictatorMilitia > 0);
  const adjacentRebelSectors = new Set<Sector>();
  // ... existing adjacency logic ...

  const sectorsToAttack = [...adjacentRebelSectors].slice(0, game.rebelCount);

  if (sectorsToAttack.length === 0) {
    return { success: true, message: 'Artillery Barrage: No valid targets' };
  }

  // Roll for all sectors upfront
  const sectorRolls: Array<{ sector: Sector; hits: number }> = [];
  for (const sector of sectorsToAttack) {
    const roll = game.rollDie();
    game.message(`Artillery targets ${sector.sectorName}: rolled ${roll} hits`);
    sectorRolls.push({ sector, hits: roll });
  }

  // Filter to sectors with actual targets and hits > 0
  const sectorsWithTargets = sectorRolls.filter(({ sector, hits }) => {
    if (hits === 0) return false;
    // Check if sector has any rebel units
    return game.rebelPlayers.some(rebel => {
      const militia = sector.getRebelMilitia(`${rebel.position}`);
      const mercs = game.getMercsInSector(sector, rebel);
      return militia > 0 || mercs.length > 0;
    });
  });

  if (sectorsWithTargets.length === 0) {
    return { success: true, message: 'Artillery Barrage: All misses or no targets' };
  }

  // Build pending state for first sector
  const firstSector = sectorsWithTargets[0];
  const validTargets = buildArtilleryTargets(game, firstSector.sector);

  // Queue remaining sectors
  const remaining = sectorsWithTargets.slice(1).map(({ sector, hits }) => ({
    sectorId: sector.sectorId,
    sectorName: sector.sectorName,
    hits,
  }));

  game.pendingArtilleryAllocation = {
    sectorId: firstSector.sector.sectorId,
    sectorName: firstSector.sector.sectorName,
    hits: firstSector.hits,
    allocatedHits: 0,
    validTargets,
    sectorsRemaining: remaining,
  };

  return {
    success: true,
    message: `Artillery Barrage: Allocate ${firstSector.hits} hits at ${firstSector.sectorName}`,
    data: { sectorsHit: sectorsWithTargets.length, pending: true },
  };
}
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>artilleryBarrage sets pendingArtilleryAllocation state for first sector</done>
</task>

<task type="auto">
  <name>Task 2: Add helper function to build valid targets list</name>
  <files>src/rules/tactics-effects.ts</files>
  <action>
Add a helper function `buildArtilleryTargets` that creates the valid targets array for a sector:

```typescript
/**
 * Build list of valid targets for artillery allocation in a sector
 */
function buildArtilleryTargets(game: MERCGame, sector: Sector): Array<{
  id: string;
  name: string;
  type: 'militia' | 'merc';
  ownerId: string;
  currentHealth: number;
  maxHealth: number;
}> {
  const targets: Array<{
    id: string;
    name: string;
    type: 'militia' | 'merc';
    ownerId: string;
    currentHealth: number;
    maxHealth: number;
  }> = [];

  for (const rebel of game.rebelPlayers) {
    const playerId = `${rebel.position}`;

    // Add militia as single target per player (with count as "health")
    const militiaCount = sector.getRebelMilitia(playerId);
    if (militiaCount > 0) {
      targets.push({
        id: `militia-${playerId}-${sector.sectorId}`,
        name: `${rebel.position} Militia (${militiaCount})`,
        type: 'militia',
        ownerId: playerId,
        currentHealth: militiaCount, // Each hit kills one militia
        maxHealth: militiaCount,
      });
    }

    // Add individual MERCs
    const mercs = game.getMercsInSector(sector, rebel);
    for (const merc of mercs) {
      targets.push({
        id: merc.id,
        name: merc.mercName,
        type: 'merc',
        ownerId: playerId,
        currentHealth: merc.health - merc.damage, // Available health
        maxHealth: merc.health,
      });
    }
  }

  return targets;
}
```

Place this helper above the artilleryBarrage function.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>buildArtilleryTargets helper function added and used by artilleryBarrage</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes
- [ ] `npm test` passes (no regressions)
- [ ] artilleryBarrage now sets pendingArtilleryAllocation state
- [ ] buildArtilleryTargets correctly identifies militia and MERCs
- [ ] Sectors are queued for sequential processing
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- No test regressions
- Artillery Barrage sets pending state, ready for allocation action to process
</success_criteria>

<output>
After completion, create `.planning/phases/08-artillery-barrage/08-03-SUMMARY.md`
</output>
