---
phase: 08-artillery-barrage
plan: 04
type: execute
---

<objective>
Create artilleryAllocateHits action for rebel hit allocation.

Purpose: Enable rebels to choose how artillery damage is distributed to their units during dictator's Artillery Barrage.
Output: Fully functional artilleryAllocateHits action that allocates hits and advances to next sector.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./08-04-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-artillery-barrage/08-01-SUMMARY.md
@.planning/phases/08-artillery-barrage/08-02-SUMMARY.md
@.planning/phases/08-artillery-barrage/08-03-SUMMARY.md
@src/rules/actions/rebel-combat.ts

**Pattern to follow:**
Look at `createCombatAllocateHitsAction` (lines 288-400 of rebel-combat.ts).
It uses:
- `.condition()` to check if allocation is pending
- `.chooseFrom()` with multiSelect to pick targets
- `.execute()` to apply damage and continue combat

**Artillery action differences:**
1. Uses `game.pendingArtilleryAllocation` not `game.activeCombat.pendingHitAllocation`
2. Must apply damage to militia (sector.removeRebelMilitia) and MERCs (merc.takeDamage)
3. After applying hits, must advance to next sector in queue or clear state
4. Condition should be available to ALL rebels (any rebel can allocate their units' hits)

**Multi-player consideration:**
In multiplayer, different rebels may have units in the same sector.
The action should let the rebel allocate hits to THEIR OWN units only.
After one rebel allocates, check if other rebels have units - if so, keep pending.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create artilleryAllocateHits action</name>
  <files>src/rules/actions/rebel-combat.ts</files>
  <action>
Add a new action creator function `createArtilleryAllocateHitsAction`:

```typescript
/**
 * Allocate artillery barrage hits to rebel units.
 * Called during dictator's turn when Artillery Barrage targets rebel sectors.
 * Each rebel allocates hits to their own units in the targeted sector.
 */
export function createArtilleryAllocateHitsAction(game: MERCGame): ActionDefinition {
  return Action.create('artilleryAllocateHits')
    .prompt('Allocate artillery damage')
    .condition((ctx) => {
      // Must have pending artillery allocation
      if (!game.pendingArtilleryAllocation) return false;

      // Must be a rebel player
      if (!isRebelPlayer(ctx.player)) return false;

      // Player must have units in the targeted sector
      const pending = game.pendingArtilleryAllocation;
      const playerId = `${ctx.player.position}`;
      const hasTargets = pending.validTargets.some(t => t.ownerId === playerId);

      return hasTargets;
    })
    .chooseFrom<string>('allocations', {
      prompt: 'Choose which of your units take the artillery hits',
      multiSelect: () => {
        const pending = game.pendingArtilleryAllocation;
        if (!pending) return undefined;
        // Must allocate exactly `hits` damage (or all available health)
        const totalHits = pending.hits - pending.allocatedHits;
        return { min: 1, max: totalHits };
      },
      choices: (ctx) => {
        const pending = game.pendingArtilleryAllocation;
        if (!pending) return [];

        const playerId = `${ctx.player.position}`;
        const choices: Array<{ value: string; display: string }> = [];

        // Build choices for this player's targets only
        for (const target of pending.validTargets) {
          if (target.ownerId !== playerId) continue;

          // Allow selecting up to currentHealth times
          for (let i = 0; i < target.currentHealth; i++) {
            choices.push({
              value: `${target.id}::${i}`,
              display: target.type === 'militia'
                ? `Militia (${target.currentHealth - i} remaining)`
                : target.name,
            });
          }
        }
        return choices;
      },
    })
    .execute((args, ctx) => {
      if (!game.pendingArtilleryAllocation) {
        return { success: false, message: 'No artillery allocation pending' };
      }

      const pending = game.pendingArtilleryAllocation;
      const playerId = `${ctx.player.position}`;
      const player = ctx.player as RebelPlayer;

      // Parse allocations
      const allocChoices = Array.isArray(args.allocations)
        ? args.allocations as unknown[]
        : [args.allocations];

      const hitsByTarget = new Map<string, number>();
      for (const choice of allocChoices) {
        const choiceStr = typeof choice === 'string' ? choice :
          (choice && typeof choice === 'object' && 'value' in choice)
            ? String((choice as { value: unknown }).value)
            : String(choice);
        const targetId = choiceStr.split('::')[0];
        hitsByTarget.set(targetId, (hitsByTarget.get(targetId) ?? 0) + 1);
      }

      // Apply damage
      const sector = game.getSector(pending.sectorId);
      let totalApplied = 0;

      for (const [targetId, hits] of hitsByTarget) {
        const target = pending.validTargets.find(t => t.id === targetId);
        if (!target || target.ownerId !== playerId) continue;

        if (target.type === 'militia') {
          // Remove militia from sector
          const removed = sector?.removeRebelMilitia(playerId, hits) ?? 0;
          if (removed > 0) {
            game.message(`${removed} militia killed by artillery at ${pending.sectorName}`);
          }
          totalApplied += removed;

          // Update target health in pending state
          target.currentHealth -= removed;
        } else {
          // Damage MERC
          const merc = player.team.find(m => m.id === targetId);
          if (merc) {
            for (let i = 0; i < hits; i++) {
              merc.takeDamage(1);
              game.message(`${merc.mercName} takes 1 artillery damage`);
              totalApplied++;
            }
            target.currentHealth = merc.health - merc.damage;
          }
        }
      }

      // Update allocated count
      pending.allocatedHits += totalApplied;

      // Check if all hits for this sector are allocated
      // (or all targets exhausted)
      const remainingTargets = pending.validTargets.filter(t => t.currentHealth > 0);
      const allHitsAllocated = pending.allocatedHits >= pending.hits || remainingTargets.length === 0;

      if (allHitsAllocated) {
        // Move to next sector or complete
        if (pending.sectorsRemaining.length > 0) {
          const next = pending.sectorsRemaining.shift()!;
          const nextSector = game.getSector(next.sectorId);
          if (nextSector) {
            const nextTargets = buildArtilleryTargets(game, nextSector);
            game.pendingArtilleryAllocation = {
              sectorId: next.sectorId,
              sectorName: next.sectorName,
              hits: next.hits,
              allocatedHits: 0,
              validTargets: nextTargets,
              sectorsRemaining: pending.sectorsRemaining,
            };
            game.message(`Artillery Barrage continues: ${next.hits} hits at ${next.sectorName}`);
          }
        } else {
          // All sectors processed
          game.pendingArtilleryAllocation = null;
          game.message('Artillery Barrage complete');
        }
      }

      return {
        success: true,
        message: `Allocated ${totalApplied} artillery hits`,
        data: { allocated: totalApplied },
      };
    });
}
```

Note: This requires importing `buildArtilleryTargets` from tactics-effects.ts.
Export it from tactics-effects.ts and import in rebel-combat.ts.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>artilleryAllocateHits action created with proper condition, choices, and execution</done>
</task>

<task type="auto">
  <name>Task 2: Export buildArtilleryTargets and wire up imports</name>
  <files>src/rules/tactics-effects.ts, src/rules/actions/rebel-combat.ts, src/rules/actions/index.ts</files>
  <action>
1. In tactics-effects.ts, export the buildArtilleryTargets function:
   Change `function buildArtilleryTargets` to `export function buildArtilleryTargets`

2. In rebel-combat.ts, add import:
   `import { buildArtilleryTargets } from '../tactics-effects.js';`

3. In index.ts, ensure the action is properly registered:
   - Add to imports: `createArtilleryAllocateHitsAction`
   - Add to registration: `createArtilleryAllocateHitsAction(game)`

4. Update the stub from Plan 02 if one was created - replace with the real implementation.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>All imports and exports properly wired, action registered</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Artillery Barrage player choice mechanism</what-built>
  <how-to-verify>
    1. Run: `npm run dev` to start the game
    2. Start a game with AI dictator
    3. Play until dictator plays Artillery Barrage tactics card
    4. Verify: Game pauses and asks rebel to allocate hits
    5. Verify: Can select militia or MERCs to take damage
    6. Verify: After allocation, artillery continues to next sector if applicable
    7. Verify: After all sectors processed, dictator turn continues normally
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes
- [ ] `npm test` passes (no regressions)
- [ ] Artillery Barrage pauses for rebel hit allocation
- [ ] Rebels can choose which units take hits
- [ ] Multi-sector artillery works (processes queue)
- [ ] Game continues normally after allocation
</verification>

<success_criteria>
- All tasks completed
- Human verification passed
- All verification checks pass
- No TypeScript errors
- No test regressions
- Artillery Barrage player choice fully functional
- Phase 8 complete
</success_criteria>

<output>
After completion, create `.planning/phases/08-artillery-barrage/08-04-SUMMARY.md`
</output>
