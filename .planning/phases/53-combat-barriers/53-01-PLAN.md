---
phase: 53-combat-barriers
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/combat-barriers.test.ts
autonomous: true

must_haves:
  truths:
    - "When a rebel triggers combat during simultaneous play, all rebels exit the simultaneous step"
    - "After combat resolves, the simultaneous step resumes and remaining rebels can act"
    - "When a rebel declares a coordinated attack, the simultaneous step exits and other rebels get commit/decline"
    - "After coordinated attack resolves, simultaneous play resumes"
    - "A rebel who ended their turn before a combat barrier remains done after the barrier resolves"
  artifacts:
    - path: "tests/combat-barriers.test.ts"
      provides: "Barrier verification tests for FLOW-03 and FLOW-04"
      min_lines: 100
  key_links:
    - from: "tests/combat-barriers.test.ts"
      to: "src/rules/flow.ts"
      via: "GameRunner driving flow through barrier transitions"
      pattern: "performAction|getFlowState"
---

<objective>
Verify that the combat barrier architecture (already implemented in Phase 52) correctly handles all three success criteria: combat barriers pause and resume simultaneous play, coordinated attack barriers follow the declare/commit/resolve cycle, and players who ended their turn before a barrier stay done afterward.

Purpose: FLOW-03 and FLOW-04 require that combat and coordinated attacks act as synchronization barriers. The flow structure is already wired (allDone exits on pendingCombat/activeCombat/coordinatedAttack, outer loop resolves them, simultaneousActionStep re-enters). This plan proves the wiring works through targeted integration tests. If tests reveal any bugs, fix them in the same task.

Output: `tests/combat-barriers.test.ts` with passing tests covering all three barrier scenarios.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/53-combat-barriers/53-RESEARCH.md
@src/rules/flow.ts
@src/rules/game.ts
@src/rules/combat.ts
@src/rules/actions/rebel-movement.ts
@tests/mcts-clone.test.ts
@tests/smoke.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write combat barrier integration tests</name>
  <files>tests/combat-barriers.test.ts</files>
  <action>
Create `tests/combat-barriers.test.ts` with three test groups covering the Phase 53 success criteria. Use the GameRunner pattern from mcts-clone.test.ts (not createTestGame) since we need fine-grained control over action submission for multi-player games.

**Test infrastructure (reuse from mcts-clone.test.ts pattern):**
- `autoResolveArgs(game, actionName, playerSeat)` — picks first valid selection for any action
- `getCurrentAction(flowState)` — handles both simultaneous (awaitingPlayers) and sequential (currentPlayer) modes
- Use 3-player games (2 rebels + 1 dictator) so one rebel can trigger a barrier while the other still has actions
- Use `dictatorIsAI: true` so we don't have to manually drive dictator turns
- Use deterministic seeds so tests are repeatable

**Test Group 1: Combat Barrier (FLOW-03) — "When a rebel triggers combat, simultaneous step exits and resumes"**

Set up a 3-player game. Drive both rebels through Day 1 (placeLanding, hireFirstMerc, hireSecondMerc, equipStarting, endTurn for each rebel, then dictator setup auto-resolves). Advance to Day 2+ rebel phase where both rebels are in the simultaneousActionStep('rebel-actions').

To trigger combat: one rebel needs to `move` into a sector with dictator militia. The move action sets `game.pendingCombat`, which causes `allDone` to return true. After move succeeds:
1. Assert `game.pendingCombat !== null` — the barrier trigger state is set
2. Get flowState — it should NOT have `awaitingPlayers` with rebel-actions (simultaneous step exited)
3. Drive through combat resolution actions (combatResolutionFlow produces combat roll, casualty, animation wait steps)
4. After all combat actions resolve, assert `game.activeCombat === null` and `game.pendingCombat === null`
5. Get flowState — it should have `awaitingPlayers` again (simultaneous step re-entered) with the second rebel who still has actions

If setting up the combat trigger is too complex (need dictator militia in a reachable sector), use a simpler approach: manually set `game.pendingCombat = { sectorId, playerId }` after a rebel takes any action, then verify the flow exits and resumes correctly. Document why the manual setup was used.

**Test Group 2: Coordinated Attack Barrier (FLOW-04) — "Declare exits simultaneous step, commit/decline runs, then resumes"**

This is harder to set up because coordinated attack requires 2+ rebels with squads in adjacent sectors and specific conditions. If the natural setup is too complex for a test, verify the barrier pattern indirectly:
1. Manually set `game.coordinatedAttack = { declaringPlayerSeat, targetSectorId, committedSquads: [...] }` during a rebel's turn in the simultaneous step
2. Assert `allDone` returns true when `coordinatedAttack` is set (call the function directly or check flow state)
3. Verify the flow transitions to the `coordinated-attack-commit` simultaneous step
4. After resolving, verify the main rebel-actions simultaneous step resumes

If direct coordinated attack action testing is feasible (rebels in adjacent sectors, eligible squads), do that instead. The key assertion is that the simultaneous step exits and resumes around the coordinated attack barrier.

**Test Group 3: Done Before Barrier Preservation — "Player who ended turn stays done after barrier"**

Set up a 3-player game. In Day 2+ rebel phase:
1. Have Rebel 1 call `endTurn` — verify their MERCs all have `actionsRemaining === 0`
2. Have Rebel 2 trigger a combat barrier (via move or manual pendingCombat setup)
3. Drive through combat resolution
4. After barrier resolves, check flowState.awaitingPlayers:
   - Rebel 1 should NOT be in awaitingPlayers (they ended turn before barrier)
   - Rebel 2 should be in awaitingPlayers if they have actions remaining
5. This proves `skipPlayer`/`playerDone` checking `actionsRemaining === 0` works across barrier exits

**Important implementation notes:**
- Import from `boardsmith/runtime` for GameRunner, from `boardsmith` for serializeAction/deserializeAction
- Start runner with `runner.start()`, get game with `runner.game`
- Submit actions with `runner.performAction(actionName, playerSeat, args)`
- Get flow state with `game.getFlowState()`
- For simultaneous steps, `flowState.awaitingPlayers` contains `{ playerIndex, availableActions, completed }` entries
- If a test reveals a bug in flow.ts, fix it in Task 2 (below). If no bugs found, Task 2 is skipped.
- Do NOT use random dice — use seeded games for deterministic combat outcomes
  </action>
  <verify>
Run `npx vitest run tests/combat-barriers.test.ts` — all tests pass.

If any test fails because of an actual flow bug (not test setup), proceed to Task 2.
  </verify>
  <done>
At least one test per success criterion passes:
1. Combat barrier: simultaneous step exits when pendingCombat is set, resumes after combat resolves
2. Coordinated attack barrier: simultaneous step exits when coordinatedAttack is set, commit/decline runs, resumes after
3. Done preservation: rebel who ended turn before barrier is not in awaitingPlayers after barrier resolves
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix any flow bugs revealed by tests (conditional)</name>
  <files>src/rules/flow.ts</files>
  <action>
If Task 1 tests all pass on first run, this task is a no-op. Mark it complete.

If any test revealed a real bug in the barrier pattern (not a test setup issue), fix it here:
- Read the failing test output carefully to identify the root cause
- The most likely bugs based on research:
  1. `activeCombat.combatComplete === true` not being cleared properly (Pitfall 1 in research)
  2. Coordinated attack declaring player incorrectly included in commit/decline step (Pitfall 2)
  3. `pendingCombatQueue` not fully draining before re-entering simultaneous step (Pitfall 3)
- Make the minimal fix in flow.ts
- Re-run the failing test to confirm it passes
- Run the full test suite to confirm no regressions

Do NOT make speculative fixes. Only fix what a failing test proves is broken.
  </action>
  <verify>
`npx vitest run tests/combat-barriers.test.ts` — all tests pass.
`npx vitest run` — full test suite passes (no regressions).
  </verify>
  <done>
All combat barrier tests pass. Full test suite has no regressions. If no bugs were found, this task completed as no-op.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run tests/combat-barriers.test.ts` — all barrier tests pass
2. `npx vitest run` — full test suite passes
3. Manual review: tests exercise all 3 success criteria from ROADMAP.md Phase 53
</verification>

<success_criteria>
- tests/combat-barriers.test.ts exists with passing tests
- Combat barrier (FLOW-03): test proves simultaneous step exits on combat trigger and resumes after resolution
- Coordinated attack barrier (FLOW-04): test proves simultaneous step exits on coordinated attack and resumes after resolution
- Done preservation: test proves players who ended turn before barrier stay done after barrier
- Full test suite passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/53-combat-barriers/53-01-SUMMARY.md`
</output>
