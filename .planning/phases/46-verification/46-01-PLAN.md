---
phase: 46-verification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/combat-events.test.ts
autonomous: true

must_haves:
  truths:
    - "combat-panel snapshot contains correct combatant data for both sides"
    - "combat-panel snapshot includes decision context at decision points"
    - "Animation events (combat-roll, combat-damage, combat-death, combat-end) carry correct data fields"
    - "combat-panel is re-emitted after player decision with updated state"
    - "All existing 602 tests still pass with zero regressions"
  artifacts:
    - path: "tests/combat-events.test.ts"
      provides: "Combat event pipeline test suite"
      min_lines: 200
  key_links:
    - from: "tests/combat-events.test.ts"
      to: "src/rules/combat.ts"
      via: "executeCombat() direct call"
      pattern: "executeCombat\\(game.*sector.*rebel"
    - from: "tests/combat-events.test.ts"
      to: "game.pendingAnimationEvents"
      via: "animation event inspection"
      pattern: "pendingAnimationEvents"
---

<objective>
Write automated tests that verify the combat event pipeline built in Phases 43-45 works end-to-end.

Purpose: This is the final verification phase for v1.9. Tests confirm the combat-panel snapshot, animation events, and decision context work correctly so the CombatPanel UI contract is guaranteed by tests.

Output: A single test file `tests/combat-events.test.ts` covering all 5 success criteria from TEST-01.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/46-verification/46-RESEARCH.md
@src/rules/combat.ts (lines 86-133 for serializeCombatant/buildCombatPanelSnapshot, lines 2344-2874 for executeCombat)
@tests/combat-execution.test.ts (existing combat test patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Combat event pipeline tests - snapshots, animation events, and lifecycle</name>
  <files>tests/combat-events.test.ts</files>
  <action>
Create `tests/combat-events.test.ts` with the following test structure. Use the same import pattern as `tests/combat-execution.test.ts`.

**Imports needed:**
```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { createTestGame } from 'boardsmith/testing';
import { MERCGame, RebelPlayer } from '../src/rules/game.js';
import { CombatantModel, Sector } from '../src/rules/elements.js';
import { executeCombat, getCombatants, type Combatant } from '../src/rules/combat.js';
```

**Test setup (shared `beforeEach`):**
- `createTestGame(MERCGame, { playerCount: 2, playerNames: ['Rebel1', 'Dictator'], seed: 'combat-events-test' })`
- Get `rebel = game.rebelPlayers[0]`, `sector = game.gameMap.getAllSectors()[0]`
- Place a merc in rebel's primary squad: `game.mercDeck.first(CombatantModel, c => c.isMerc)` then `merc.putInto(rebel.primarySquad)`, set `rebel.primarySquad.sectorId = sector.sectorId`
- Add militia: `sector.addDictatorMilitia(3)`

**Test group 1: "Combat-Panel Snapshot Contents" (Success Criteria 1)**

Tests to write:
1. `'emits combat-panel snapshot at combat start'` - Run `executeCombat(game, sector, rebel, { interactive: false })`, filter `game.pendingAnimationEvents` for `type === 'combat-panel'`, expect at least 2 (start + end). Check first snapshot has `sectorId`, `sectorName`, `round`, `rebelCombatants`, `dictatorCombatants`.
2. `'snapshot rebel combatants have correct fields'` - Check first combat-panel event's `rebelCombatants[0]` has: `id` (string), `name` (string), `image` (string), `health` (number), `maxHealth` (number), `isMerc` (true), `isMilitia` (false), `isAttackDog` (false), `isDictator` (false), `combatantId` (string), `playerColor` (string).
3. `'snapshot dictator combatants have correct fields'` - Check first snapshot's `dictatorCombatants`. Expect length 3 (matching militia count). First entry should have `isMilitia: true`, `isDictatorSide: true`, `isMerc: false`.
4. `'snapshot casualties populated during combat'` - In a non-interactive combat, find the LAST `combat-panel` event. It should have `combatComplete: true`. Check that at least one of `rebelCasualties` or `dictatorCasualties` has length > 0 (since non-interactive combat runs to completion, someone dies).
5. `'multiple combat-panel events emitted throughout combat'` - Verify at least 2 combat-panel events exist (start snapshot + end snapshot at minimum).

**Test group 2: "Animation Event Data" (Success Criteria 3)**

Tests to write:
1. `'combat-roll events carry dice data'` - Filter for `type === 'combat-roll'`. Expect at least 1. Check fields: `attackerName` (string), `attackerId` (string), `attackerImage` (string), `diceRolls` (array), `hits` (number), `hitThreshold` (number). Check `targetNames` is an array and `targetIds` is an array.
2. `'combat-damage events carry health data'` - Filter for `type === 'combat-damage'`. If any exist (depends on seed/dice), check fields: `attackerName`, `attackerId`, `targetName`, `targetId`, `targetImage`, `damage` (number), `healthBefore` (number), `healthAfter` (number). Verify `healthAfter <= healthBefore` and `damage === healthBefore - healthAfter`.
3. `'combat-death events carry target data'` - Filter for `type === 'combat-death'`. If any exist, check: `targetName` (string), `targetId` (string), `targetImage` (string).
4. `'combat-end event emitted when combat finishes'` - Filter for `type === 'combat-end'`. Expect exactly 1. Check it has `rebelVictory` (boolean) and `dictatorVictory` (boolean). Exactly one should be true (XOR, since non-interactive combat without retreat always has a winner).
5. `'combat-round-start events carry round number'` - Filter for `type === 'combat-round-start'`. Expect at least 1. Check first has `round` (number) and `round >= 1`.
6. `'events are emitted in logical order'` - Verify ordering: first event should be `combat-panel`, last event should be `combat-end`, and every `combat-roll` should come before any `combat-damage` for the same attacker in the same round. Simplest check: first event type is `combat-panel`, last is `combat-end`.

**Test group 3: "Combat Lifecycle" (Success Criteria 5)**

Tests to write:
1. `'combat-end event matches outcome'` - Compare `executeCombat` return value (`outcome.rebelVictory`/`outcome.dictatorVictory`) with the combat-end event data. They must match.
2. `'final combat-panel snapshot has combatComplete: true'` - The last `combat-panel` event should have `combatComplete: true`.
3. `'non-interactive combat does not leave activeCombat pending'` - After non-interactive executeCombat, `outcome.combatPending` should be `false`.

**Important implementation notes:**
- Use `interactive: false` for all tests in this task. Decision context tests are in Task 2.
- Test field existence and types, not exact values (seed-dependent). Use `toBeDefined()`, `typeof`, `toBeGreaterThanOrEqual()`.
- For damage/death events: they may or may not exist depending on dice. Use conditional checks (`if (events.length > 0) { ... expect ... }`) for events that depend on combat outcomes, but wrap them so at least the event TYPE existence is checked at the group level.
- Actually, with seed 'combat-events-test' and 3 militia vs 1 merc, combat will definitely produce rolls, likely damage, and likely deaths. If a specific seed produces no damage events, try seed 'combat-events-damage' or add more militia (5+).
  </action>
  <verify>
Run `npx vitest run tests/combat-events.test.ts --reporter=verbose` -- all tests pass.
Run `npx vitest run --reporter=verbose` -- all 602+ tests pass (no regressions).
  </verify>
  <done>
Tests verify combat-panel snapshot contains correct combatant data (both sides, health, images, type flags). Tests verify animation events carry correct data (roll details, damage amounts, death info). Tests verify combat-end is emitted when combat finishes and matches outcome. All existing tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Decision context and snapshot re-emission tests</name>
  <files>tests/combat-events.test.ts</files>
  <action>
Add two more test groups to the existing `tests/combat-events.test.ts` file created in Task 1.

**Test group 4: "Decision Context in Snapshots" (Success Criteria 2)**

This group needs a different setup than the shared `beforeEach` -- it needs `interactive: true` and conditions that trigger decision points.

Use a nested `describe` block with its own `beforeEach`:
- Same game setup as Task 1 but with MORE militia (5+) to increase chance of decision points
- Place 2+ mercs (get multiple from mercDeck) so there is multi-target potential and hit allocation scenarios
- Use `interactive: true` when calling `executeCombat`

Tests to write:
1. `'interactive combat can pause at decision point'` - Call `executeCombat(game, sector, rebel, { interactive: true })`. If `outcome.combatPending` is true, verify `game.activeCombat` is not null. Then check `game.pendingAnimationEvents` has at least one `combat-panel` event. The LAST combat-panel event should have at least one non-null decision context field (pendingTargetSelection, pendingHitAllocation, pendingWolverineSixes, pendingAttackDogSelection, pendingBeforeAttackHealing, pendingEpinephrine). If combat did NOT pause (auto-resolved because single targets), the test should still pass -- add a note that some seeds/merc-combos auto-resolve.
2. `'pendingTargetSelection has correct structure when present'` - If the last combat-panel snapshot has `pendingTargetSelection` non-null, verify it has: `attackerId` (string), `attackerName` (string), `validTargets` (array with length > 0), `maxTargets` (number). Each valid target should have `id`, `name`, `health`, `maxHealth`.
3. `'pendingHitAllocation has correct structure when present'` - Similar: if last snapshot has `pendingHitAllocation` non-null, verify structure (it should have attacker info and hit count). NOTE: The actual structure depends on what combat.ts stores on `activeCombat.pendingHitAllocation`. Read it from the snapshot event data directly.
4. `'decision context fields are mutually exclusive'` - If any combat-panel snapshot has a non-null decision context, at most one of the 6 decision context fields should be non-null. Check all combat-panel events in the buffer.

**For tests that depend on specific decision types:** If the seed does not trigger a particular decision type, make the test conditional (skip the structural checks if the field is null, but still verify the mutual exclusivity invariant holds). The key is that WHEN a decision context is present, it has the right structure. Do NOT skip the test entirely -- use conditional expects.

**Test group 5: "Snapshot Re-emission After Decision" (Success Criteria 4)**

This is the trickiest test. The research identified two approaches. Use the simpler one:

1. `'non-interactive combat emits multiple combat-panel snapshots'` - With `interactive: false`, verify that the number of `combat-panel` events is >= 2. The first has `combatComplete: false`, the last has `combatComplete: true`. This proves snapshots are emitted at multiple points in the combat lifecycle (start, round boundaries, end).
2. `'combat-panel snapshots show progression'` - In non-interactive combat, find all `combat-panel` events. Verify that the first snapshot has `round` >= 1 and the last snapshot has `combatComplete: true`. If there are 3+ snapshots, verify that later snapshots can have different casualty counts than earlier ones (showing state progression).
3. `'interactive combat emits snapshot before pausing'` - With `interactive: true`, if combat pauses (`outcome.combatPending`), verify at least one `combat-panel` event was emitted. The last combat-panel should have a non-null decision context (matching what `activeCombat` has pending).

**Important:** For the re-emission test, we cannot easily test the full "pause -> decide -> resume -> new snapshot" cycle without flow engine integration. The non-interactive multi-snapshot test demonstrates that `buildCombatPanelSnapshot` is called at each decision cycle point. The interactive test demonstrates the snapshot is emitted before pausing. Together these satisfy Success Criteria 4's intent.
  </action>
  <verify>
Run `npx vitest run tests/combat-events.test.ts --reporter=verbose` -- all tests pass (both Task 1 and Task 2 tests).
Run `npx vitest run --reporter=verbose` -- all tests pass (no regressions).
  </verify>
  <done>
Tests verify snapshot includes appropriate decision context at decision points. Tests verify combat-panel is re-emitted at multiple points throughout combat with updated state. Tests verify decision context fields are correctly structured when present. All tests pass with zero regressions.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run tests/combat-events.test.ts --reporter=verbose` -- all new tests pass
2. `npx vitest run --reporter=verbose` -- all 602+ tests pass (no regressions)
3. New test file covers all 5 success criteria from TEST-01:
   - SC1: combat-panel snapshot with correct combatant data (Test group 1)
   - SC2: decision context in snapshots (Test group 4)
   - SC3: animation events with correct data (Test group 2)
   - SC4: combat-panel re-emitted throughout combat (Test group 5)
   - SC5: combat-end emitted (Test group 3)
4. All existing tests still pass (SC6 from TEST-01)
</verification>

<success_criteria>
- tests/combat-events.test.ts exists with 15+ tests across 5 test groups
- All tests in combat-events.test.ts pass
- All 602 existing tests pass (zero regressions)
- Test file uses executeCombat() directly (not flow engine) following established patterns
- Tests verify structure/types, not seed-dependent exact values
</success_criteria>

<output>
After completion, create `.planning/phases/46-verification/46-01-SUMMARY.md`
</output>
