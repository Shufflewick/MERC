---
phase: 10-unified-class
plan: 01
type: execute
---

<objective>
Create unified CombatUnitCard class that combines MercCard and DictatorCard functionality.

Purpose: Establish single class with all shared functionality, making MercCard/DictatorCard thin aliases for backward compatibility during migration.
Output: CombatUnitCard class in elements.ts, MercCard/DictatorCard as aliases
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./10-01-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-add-discriminator/09-01-SUMMARY.md
@src/rules/elements.ts

**Prior decisions:**
- cardType discriminator: `'merc' | 'dictator'` string literal union
- isMerc/isDictator getters for type checking

**Key insight:** MercCard and DictatorCard both extend CombatUnit. The differences are:
- MercCard: mercId/mercName aliases, equipment overrides for Apeiron/Gunther/Genesis
- DictatorCard: dictatorId/dictatorName aliases, inPlay, baseSectorId, enterPlay()

All differences can be unified with conditional logic based on cardType.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CombatUnitCard class</name>
  <files>src/rules/elements.ts</files>
  <action>
Create new CombatUnitCard class extending CombatUnit with:
- Direct properties: unitId!, unitName! (not getters - BoardSmith populates these)
- cardType: 'merc' | 'dictator'
- isMerc/isDictator getters (check cardType)
- inPlay: boolean = true (mercs always in play, dictators start false)
- baseSectorId?: string (only used for dictators)
- enterPlay() method
- Equipment overrides from MercCard (canEquip, equip) with ID-based checks for Apeiron/Gunther/Genesis
- Backward-compat getters: mercId, mercName, dictatorId, dictatorName (all return unitId/unitName)

Place AFTER CombatUnit class, BEFORE current MercCard class.
  </action>
  <verify>npm run build passes, no TypeScript errors</verify>
  <done>CombatUnitCard class exists with all unified functionality</done>
</task>

<task type="auto">
  <name>Task 2: Make MercCard and DictatorCard extend CombatUnitCard</name>
  <files>src/rules/elements.ts</files>
  <action>
Modify MercCard to:
- Extend CombatUnitCard instead of CombatUnit
- Remove all properties/methods now in CombatUnitCard
- Keep only: mercId!, mercName! (BoardSmith populates these)
- Override unitId/unitName getters to return mercId/mercName
- Set cardType = 'merc' in class body

Modify DictatorCard to:
- Extend CombatUnitCard instead of CombatUnit
- Remove all properties/methods now in CombatUnitCard
- Keep only: dictatorId!, dictatorName! (BoardSmith populates these)
- Override unitId/unitName getters to return dictatorId/dictatorName
- Set cardType = 'dictator' in class body

This maintains backward compatibility - existing code using MercCard/DictatorCard continues to work.
  </action>
  <verify>npm run build passes, npm test shows same 56 failures (no new failures)</verify>
  <done>MercCard and DictatorCard are thin wrappers around CombatUnitCard</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm test -- --run` shows same 56 failures (pre-existing, unrelated)
- [ ] CombatUnitCard has all unified functionality
- [ ] MercCard extends CombatUnitCard
- [ ] DictatorCard extends CombatUnitCard
- [ ] Existing instanceof MercCard/DictatorCard still works
</verification>

<success_criteria>
- CombatUnitCard class created with unified functionality
- MercCard and DictatorCard are thin subclasses
- No new test failures introduced
- Build passes
</success_criteria>

<output>
After completion, create `.planning/phases/10-unified-class/10-01-SUMMARY.md`
</output>
