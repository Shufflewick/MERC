---
phase: 52-simultaneous-rebel-step
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/rules/flow.ts
autonomous: true

must_haves:
  truths:
    - "Multiple rebel players can submit actions during the same rebel phase without waiting for each other"
    - "Each rebel sees only the actions available to them based on their own state and board state"
    - "A rebel who ends their turn is skipped when the simultaneous step re-enters after combat"
    - "The rebel phase completes only when all rebels are done"
    - "Combat breaks out of the simultaneous step, resolves sequentially, then re-enters"
    - "Mortar allocation targets the correct player even outside eachPlayer context"
    - "Coordinated attack response runs outside the simultaneous step without deadlock"
  artifacts:
    - path: "src/rules/flow.ts"
      provides: "Day 2+ rebel phase using loop + simultaneousActionStep"
      contains: "simultaneousActionStep"
  key_links:
    - from: "simultaneousActionStep allDone"
      to: "game.pendingCombat / game.coordinatedAttack / game.pendingMortarAttack"
      via: "allDone callback checks combat state to break out"
      pattern: "allDone.*pendingCombat"
    - from: "mortar actionStep"
      to: "game.pendingMortarAttack.attackingPlayerId"
      via: "player: override resolves firing player from pendingMortarAttack"
      pattern: "player:.*pendingMortarAttack"
    - from: "Oil Reserves execute block"
      to: "applyOilReservesEffect for ALL rebels"
      via: "execute block before simultaneous step iterates rebelPlayers"
      pattern: "applyOilReservesEffect.*rebelPlayers"
---

<objective>
Replace the sequential `eachPlayer('rebel-turns')` Day 2+ rebel phase with a `loop` wrapping `simultaneousActionStep` so all rebels act in parallel.

Purpose: This is the core structural change for simultaneous rebel play. Combat, mortar, and coordinated attacks break out of the simultaneous step via `allDone`, resolve in the outer loop, then re-enter.

Output: Updated flow.ts with Day 2+ rebel phase using simultaneousActionStep. All existing tests pass.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-simultaneous-rebel-step/52-RESEARCH.md
@.planning/phases/51-extract-combat-sub-flow/51-01-SUMMARY.md
@src/rules/flow.ts
@src/rules/game.ts (pendingMortarAttack type at line 639, has attackingPlayerId field)
@src/rules/actions/rebel-economy.ts (endTurn action at line 1290, condition 'day 2 or later')
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace eachPlayer rebel-turns with loop + simultaneousActionStep</name>
  <files>src/rules/flow.ts</files>
  <action>
Replace the `eachPlayer({ name: 'rebel-turns', ... })` block (lines 609-746) with the following structure:

1. **Oil Reserves execute block** — Move BEFORE the loop. Iterate `game.rebelPlayers` and call `applyOilReservesEffect(game, true, player)` for each rebel. This replaces the per-player execute that ran at the start of each sequential turn. It must run once per day for all rebels.

2. **Outer loop** — `loop({ name: 'rebel-phase', while: ..., maxIterations: 200, do: sequence(...) })`. The `while` condition continues while:
   - `game.isFinished()` is false, AND
   - ANY of: `activeCombat` not complete, `pendingCombat` or `pendingCombatQueue` not empty, `coordinatedAttack` not null, `pendingMortarAttack` not null, OR any rebel has `actionsRemaining > 0`

3. **Inside the sequence** (in order):
   a. **Initiate pending combat execute block** — Same logic as current lines 641-657 but without `ctx.player` dependency: dequeue from `pendingCombatQueue` to `pendingCombat`, then initiate via `executeCombat`. The player comes from `game.pendingCombat.playerId`.

   b. **Combat resolution** — `combatResolutionFlow(game, 'combat')` (already extracted in Phase 51)

   c. **Mortar allocation loop** — Same structure as current lines 695-705 BUT add `player:` override to the actionStep:
   ```typescript
   player: () => {
     const pending = game.pendingMortarAttack;
     if (!pending) return game.rebelPlayers[0]; // fallback, won't execute
     const firingPlayer = game.rebelPlayers.find(p => `${p.seat}` === pending.attackingPlayerId);
     return firingPlayer ?? game.rebelPlayers[0];
   }
   ```
   This is CRITICAL — without `eachPlayer`, `ctx.player` is not set for the mortar actionStep. The `attackingPlayerId` on `pendingMortarAttack` identifies who fired.

   d. **Coordinated attack response loop** — Move the existing coordinated-attack-response block (lines 708-742) here. No changes needed to the inner simultaneousActionStep or execute — it already works independently.

   e. **Main simultaneousActionStep** — `simultaneousActionStep({ name: 'rebel-actions', ... })` with:
   - `players: () => game.rebelPlayers` (engine handles filtering via skipPlayer)
   - `actions:` — Same action list as current rebel-action step (lines 669-688): move, coordinatedAttack, declareMultiPlayerAttack, explore, train, hireMerc, reEquip, dropEquipment, hospital, feedbackDiscard, squidheadDisarm, squidheadArm, hagnessDrawType, hagnessGiveEquipment, armsDealer, repairKit, mortar, assignToSquad, endTurn
   - `skipPlayer: (_ctx, player) => { if (game.isFinished()) return true; return !player.team.some(m => m.actionsRemaining > 0); }` — Skip rebels who are done (all actionsRemaining === 0, which endTurn sets)
   - `playerDone: (_ctx, player) => { return !player.team.some(m => m.actionsRemaining > 0); }` — Same check; engine uses this after each action
   - `allDone: () => { ... }` — Returns true if:
     - `game.isFinished()`, OR
     - `game.activeCombat !== null && !game.activeCombat.combatComplete`, OR
     - `game.pendingCombat !== null || game.pendingCombatQueue.length > 0`, OR
     - `game.coordinatedAttack !== null`, OR
     - `game.pendingMortarAttack != null`, OR
     - All rebels done: `game.rebelPlayers.every(p => !p.team.some(m => m.actionsRemaining > 0))`

Important implementation notes:
- Do NOT nest mortar/coordinated-attack inside the simultaneousActionStep — they use regular actionSteps that need ctx.player set
- Do NOT add a custom "done" flag — use existing actionsRemaining === 0 check
- The `skipIf` on the old rebel-action step (`game.activeCombat !== null && !game.activeCombat.combatComplete`) is no longer needed — the simultaneousActionStep's `allDone` breaks out before any rebel can act during active combat
- Keep the `skipIf` guard on the rebel-action inside simultaneousActionStep as a safety check: the engine's allDone should catch combat state first, but if somehow an action fires during combat, the skipIf prevents it. WAIT — there is no inner actionStep in simultaneousActionStep, the actions list IS the simultaneous step. The conditions on each action already prevent acting during combat (e.g., 'not in combat' on most actions). This is sufficient.
  </action>
  <verify>
Run `npm test` — all 682+ tests must pass. No behavioral regressions. The flow structure change is transparent to actions since action conditions already gate on game state (combat active, player state, etc.).
  </verify>
  <done>
The Day 2+ rebel phase in flow.ts uses `loop` + `simultaneousActionStep` instead of `eachPlayer`. Oil Reserves applies to all rebels before the loop. Combat, mortar, and coordinated attack break out of the simultaneous step and resolve in the outer loop. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify full test suite and multi-player flow correctness</name>
  <files>src/rules/flow.ts</files>
  <action>
Run the full test suite. If any tests fail, diagnose and fix. Pay special attention to:

1. **Combat flow tests** (combat-execution.test.ts, combat-events.test.ts, combat-abilities.test.ts) — Combat resolution must still work correctly when triggered from the simultaneous step's allDone breakout
2. **Multi-player tests** (landing-zone-multi-player.test.ts) — Multi-player scenarios should work with the new flow
3. **Smoke tests** (smoke.test.ts) — End-to-end game completion
4. **MCTS clone** (mcts-clone.test.ts) — Game cloning works with new flow structure (known flaky, ~106-115s, pre-existing)
5. **Action conditions** (action-conditions.test.ts) — Action availability is unchanged

If a test fails because it relied on sequential rebel turns (e.g., testing that Player 1 acts before Player 2), the test may need updating to account for simultaneous availability. But most tests use single-rebel games where sequential vs simultaneous is identical.

Check that the flow compiles cleanly with `npx tsc --noEmit`.
  </action>
  <verify>
`npm test` passes. `npx tsc --noEmit` has no errors. If any test needed modification, document the change and why.
  </verify>
  <done>
All tests pass. TypeScript compiles cleanly. No behavioral regressions from the flow restructuring.
  </done>
</task>

</tasks>

<verification>
- `npm test` passes (all 682+ tests)
- `npx tsc --noEmit` compiles cleanly
- flow.ts contains `simultaneousActionStep({ name: 'rebel-actions'` for Day 2+ rebel phase
- flow.ts no longer contains `eachPlayer({ name: 'rebel-turns'`
- Oil Reserves is applied to all rebels in a single execute block before the rebel loop
- Mortar actionStep has `player:` override using `pendingMortarAttack.attackingPlayerId`
</verification>

<success_criteria>
- Day 2+ rebel phase uses simultaneousActionStep (FLOW-02)
- Rebels who ended turn are skipped on re-entry via skipPlayer (FLOW-07)
- Per-player action evaluation via simultaneousActionStep's per-player actions callback (ACT-01)
- Action conditions provide server-side validation per player (ACT-02)
- Done = all actionsRemaining === 0 OR explicit endTurn (ACT-03)
- Phase completes when all rebels done via playerDone + allDone (ACT-04)
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/52-simultaneous-rebel-step/52-01-SUMMARY.md`
</output>
