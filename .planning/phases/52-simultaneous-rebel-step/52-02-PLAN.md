---
phase: 52-simultaneous-rebel-step
plan: 02
type: execute
wave: 2
depends_on: ["52-01"]
files_modified:
  - src/rules/flow.ts
autonomous: true

must_haves:
  truths:
    - "Day 1 rebel players can place landing and hire MERCs without waiting for each other"
    - "Each rebel progresses through landing steps independently based on their own state"
    - "A rebel who completes all hiring steps is skipped when the simultaneous step re-evaluates"
    - "Teresa bonus third hire works correctly in simultaneous mode"
    - "Day 1 uses the same simultaneousActionStep model as Day 2+"
  artifacts:
    - path: "src/rules/flow.ts"
      provides: "Day 1 rebel phase using loop + simultaneousActionStep"
      contains: "rebel-landing-actions"
  key_links:
    - from: "simultaneousActionStep playerDone"
      to: "isDay1Complete helper"
      via: "playerDone calls isDay1Complete to check landing + hiring state"
      pattern: "isDay1Complete"
    - from: "Day 1 action conditions"
      to: "ctx.player state"
      via: "placeLanding checks 'has not landed yet', hireFirstMerc checks 'has no MERCs yet', etc."
      pattern: "has not landed|has no MERCs|has 1 MERC"
---

<objective>
Replace the sequential `eachPlayer('rebel-landing')` Day 1 rebel phase with a `loop` wrapping `simultaneousActionStep` so all rebels complete their landing setup in parallel.

Purpose: Requirement FLOW-06 says Day 1 uses the same simultaneous model as Day 2+. Rebels should not wait for each other during landing and hiring.

Output: Updated flow.ts with Day 1 rebel phase using simultaneousActionStep. All existing tests pass.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-simultaneous-rebel-step/52-RESEARCH.md
@.planning/phases/52-simultaneous-rebel-step/52-01-SUMMARY.md
@src/rules/flow.ts
@src/rules/actions/day-one-actions.ts (action conditions: placeLanding, hireFirstMerc, hireSecondMerc, hireThirdMerc)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace eachPlayer rebel-landing with loop + simultaneousActionStep</name>
  <files>src/rules/flow.ts</files>
  <action>
Replace the `eachPlayer({ name: 'rebel-landing', ... })` block in the Day 1 landing phase with a simultaneous structure.

1. **Add `isDay1Complete` helper function** in flow.ts (near the other helper functions at the top):
```typescript
/** Check if a rebel has completed Day 1 setup (landed + hired MERCs) */
function isDay1Complete(game: MERCGame, player: Player): boolean {
  if (!game.isRebelPlayer(player)) return true;
  const rebel = player as RebelPlayer;
  // Must have landed
  if (!rebel.primarySquad.sectorId) return false;
  // Must have at least 2 MERCs
  const teamSize = rebel.team.length;
  if (teamSize < 2) return false;
  // If Teresa was hired, must have 3 MERCs (or must have responded to third hire)
  // The hireThirdMerc action handles the "Skip" option, after which the drawn MERCs cache is cleared
  // If team has Teresa and only 2 MERCs, check if the third hire cache is empty (meaning they chose to skip or already hired)
  if (teamSize === 2) {
    const hasTeresa = rebel.team.some(m => m.combatantId === 'teresa');
    if (hasTeresa) {
      // If Teresa is on team with only 2 MERCs, player might still need to make third hire decision
      // The hireThirdMerc action condition checks: team.length === 2 && hasTeresa && remaining.length > 0
      // Once the action fires (hire or skip), either team grows to 3 or cache is cleared
      // So if the action is still available, player is NOT done
      // We can check: if remaining mercs in cache > 0, not done yet
      // BUT we don't have direct access to the cache here. Instead, rely on the action system:
      // The simultaneousActionStep will show hireThirdMerc as available if conditions pass.
      // playerDone returning false keeps them in. The action system handles the rest.
      // For safety, return false here — the player will naturally become done when
      // hireThirdMerc fires (team grows to 3) or no more actions are available
      // (engine auto-completes players with no available actions, per engine.ts line 1106/365-367)
      return false;
    }
  }
  return true;
}
```

WAIT — the above is over-complicated. The engine auto-completes players who have no available actions (engine.ts line 1106, 365-367). So if a player has finished all steps, none of the Day 1 actions will be available, and the engine marks them done. We just need a reasonable `playerDone` check that catches the obvious case.

**Simpler approach:**
```typescript
function isDay1Complete(game: MERCGame, player: Player): boolean {
  if (!game.isRebelPlayer(player)) return true;
  const rebel = player as RebelPlayer;
  if (!rebel.primarySquad.sectorId) return false;
  // 2+ MERCs means at minimum placeLanding + hireFirstMerc + hireSecondMerc are done
  // Teresa third hire: if team is 2 and Teresa is there, hireThirdMerc is still available
  // The engine will keep them in as long as hireThirdMerc action is available
  // When they hire third (team=3) or skip (cache cleared, action unavailable), engine auto-completes
  return rebel.team.length >= 2 && !rebel.team.some(m => m.combatantId === 'teresa' && rebel.team.length === 2);
}
```

Actually even simpler — just check team size. With Teresa, you need 3. Without Teresa, you need 2. The `primarySquad.sectorId` check ensures they've landed.

```typescript
function isDay1Complete(game: MERCGame, player: Player): boolean {
  if (!game.isRebelPlayer(player)) return true;
  const rebel = player as RebelPlayer;
  if (!rebel.primarySquad.sectorId) return false;
  const hasTeresa = rebel.team.some(m => m.combatantId === 'teresa');
  const requiredSize = hasTeresa ? 3 : 2;
  return rebel.team.length >= requiredSize;
}
```

BUT: Teresa third hire has a "Skip" option. If they skip, team stays at 2 with Teresa. In that case, `isDay1Complete` returns false, but hireThirdMerc has no remaining cache so its condition fails. The engine sees no available actions and auto-completes the player. So `isDay1Complete` returning false is fine — the engine handles it.

HOWEVER: if `playerDone` returns false but no actions are available, the engine auto-completes the player anyway (line 365-367, 1106). So a conservative `isDay1Complete` that sometimes returns false when the player IS done is safe — the engine catches it. A `isDay1Complete` that returns true when the player is NOT done would be bad (skips them prematurely).

Use the simple version. It's conservative (might return false when done after Teresa skip), and the engine handles the rest.

2. **Replace `eachPlayer({ name: 'rebel-landing', ... })` with:**
```typescript
loop({
  name: 'rebel-landing',
  while: () => !game.isFinished() && game.rebelPlayers.some(p => !isDay1Complete(game, p)),
  maxIterations: 50,
  do: simultaneousActionStep({
    name: 'rebel-landing-actions',
    players: () => game.rebelPlayers,
    actions: ['placeLanding', 'hireFirstMerc', 'hireSecondMerc', 'hireThirdMerc'],
    skipPlayer: (_ctx, player) => isDay1Complete(game, player),
    playerDone: (_ctx, player) => isDay1Complete(game, player),
  }),
}),
```

This replaces the entire eachPlayer block (which had sequential actionSteps for place-landing, hire-first-merc, hire-second-merc, hire-third-merc inside a per-player sequence). The action conditions on each Day 1 action already gate progression:
- `placeLanding`: 'has not landed yet' (checks `!primarySquad.sectorId`)
- `hireFirstMerc`: 'has no MERCs yet' (checks `team.length === 0`)
- `hireSecondMerc`: 'has 1 MERC and 2+ remaining to hire'
- `hireThirdMerc`: 'Teresa bonus: can hire third MERC'

So each rebel will only see their next valid action. The simultaneousActionStep lets them progress independently.

The `while` condition on the outer loop ensures re-entry if `isDay1Complete` is conservative (returns false after Teresa skip). The engine's auto-complete for players with no available actions will mark them done inside the simultaneousActionStep.
  </action>
  <verify>
Run `npm test` — all tests must pass. Specifically check `landing-zone-multi-player.test.ts` for multi-player Day 1 scenarios. Run `npx tsc --noEmit` for clean compilation.
  </verify>
  <done>
Day 1 rebel phase uses `loop` + `simultaneousActionStep` instead of `eachPlayer`. The `isDay1Complete` helper checks landing + team size. Action conditions naturally gate per-player progression. All tests pass.
  </done>
</task>

</tasks>

<verification>
- `npm test` passes (all tests)
- `npx tsc --noEmit` compiles cleanly
- flow.ts contains `simultaneousActionStep({ name: 'rebel-landing-actions'` for Day 1
- flow.ts no longer contains `eachPlayer({ name: 'rebel-landing'`
- `isDay1Complete` helper exists and is used by skipPlayer/playerDone
- landing-zone-multi-player tests pass (Day 1 multi-player scenarios)
</verification>

<success_criteria>
- Day 1 rebel phase uses simultaneousActionStep (FLOW-06)
- Each rebel progresses through landing steps independently
- Teresa third hire works correctly (action conditions gate it)
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/52-simultaneous-rebel-step/52-02-SUMMARY.md`
</output>
