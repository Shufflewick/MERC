---
phase: 12-merge-data-files
plan: 01
type: execute
---

<objective>
Merge mercs.json and dictators.json into a single combatants.json file and unify data loading.

Purpose: Eliminate duplicate data structures and simplify the codebase by using the cardType discriminator to distinguish unit types at runtime rather than separate files.
Output: Single combatants.json file, unified CombatantData interface, single loadCombatantData method.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./12-01-summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context (from frontmatter)
@.planning/phases/11-migrate-instanceof/11-03-SUMMARY.md

# Key files for this phase
@data/mercs.json
@data/dictators.json
@src/rules/game.ts
@src/rules/setup.ts

**Tech stack available:** cardType discriminator, isMerc/isDictator properties, property-based type guards
**Established patterns:** CombatUnitCard hierarchy, property-based type discrimination
**Constraining decisions:**
- Phase 9: cardType: 'merc' | 'dictator' discriminator added to both data files
- Phase 10: CombatUnitCard class with unified properties
- Phase 11: All instanceof checks migrated to property-based guards
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create combatants.json and unify data interface</name>
  <files>data/combatants.json, src/rules/game.ts, src/rules/setup.ts</files>
  <action>
1. Create `data/combatants.json` by merging mercs.json and dictators.json:
   - All 52 merc entries first, then 2 dictator entries
   - Normalize field order to: id, cardType, name, quantity, training, combat, initiative, ability, bio, image (plus optional sex field for some mercs)
   - Keep the cardType discriminator already present in both files

2. In `src/rules/game.ts`:
   - Create unified `CombatantData` interface (replacing both MercData and DictatorData):
     ```typescript
     interface CombatantData {
       id: string;
       cardType: 'merc' | 'dictator';
       name: string;
       quantity: number;
       training: number;
       combat: number;
       initiative: number;
       ability: string;
       bio: string;
       image: string;
       sex?: string;  // Optional, only some mercs have this
     }
     ```
   - Replace `mercData` and `dictatorData` properties with single `combatantData: CombatantData[]`
   - Update imports: `import combatantsData from '../../data/combatants.json'`
   - Replace `loadMercData` and `loadDictatorData` with single `loadCombatantData`:
     ```typescript
     loadCombatantData(data: CombatantData[]): void {
       this.combatantData = data;
       const mercEntries = data.filter(d => d.cardType === 'merc');
       for (const merc of mercEntries) {
         // Same MercCard creation logic as before
       }
     }
     ```
   - Update `performSetup` call to pass filtered dictator data where needed
   - Update any references to `this.mercData` or `this.dictatorData` to use `this.combatantData` with appropriate filtering

3. In `src/rules/setup.ts`:
   - Update `DictatorData` interface to match the new unified structure (or import from game.ts)
   - Update `setupDictator` to accept `CombatantData[]` filtered to dictators only

DO NOT delete mercs.json and dictators.json yet - that's for Phase 13.
  </action>
  <verify>
- `npm run build` succeeds with no TypeScript errors
- Game loads correctly (combatants.json parsed and cards created)
  </verify>
  <done>
- combatants.json created with all 54 entries (52 mercs + 2 dictators)
- CombatantData interface defined in game.ts
- loadCombatantData method replaces loadMercData/loadDictatorData
- setup.ts updated to use CombatantData for dictator selection
- Build passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify data integrity and run tests</name>
  <files>-</files>
  <action>
1. Verify combatants.json structure:
   - Count entries: should be 54 total (52 with cardType:"merc", 2 with cardType:"dictator")
   - Validate JSON syntax
   - Check all required fields present

2. Run full test suite to ensure no regressions:
   - `npm test`
   - All tests should pass (some may fail due to pre-existing issues documented in STATE.md)

3. Verify the game can be constructed:
   - Run build: `npm run build`
   - Check that MercCard and DictatorCard creation works correctly
  </action>
  <verify>
- `cat data/combatants.json | jq 'length'` returns 54
- `cat data/combatants.json | jq '[.[] | select(.cardType == "merc")] | length'` returns 52
- `cat data/combatants.json | jq '[.[] | select(.cardType == "dictator")] | length'` returns 2
- `npm test` runs (pre-existing failures documented in STATE.md are acceptable)
- `npm run build` succeeds
  </verify>
  <done>
- combatants.json has correct entry counts
- All JSON fields validated
- Tests run without new failures
- Build succeeds
  </done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm test` runs without new failures
- [ ] combatants.json exists with 54 entries
- [ ] Old mercs.json and dictators.json still exist (not deleted until Phase 13)
- [ ] Game loads combatants from unified file
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors introduced
- combatants.json created and in use
- Old data files preserved for Phase 13 cleanup
</success_criteria>

<output>
After completion, create `.planning/phases/12-merge-data-files/12-01-SUMMARY.md`:

# Phase 12 Plan 01: Merge Data Files Summary

**[Substantive one-liner]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

[Ready for Phase 13: Remove Legacy]
</output>
