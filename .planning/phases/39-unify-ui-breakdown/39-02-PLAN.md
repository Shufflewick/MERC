---
phase: 39-unify-ui-breakdown
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/rules/elements.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Self-targeting ability modifiers have MERC name labels (e.g., 'Stumpy's Ability' not generic 'Ability')"
  artifacts:
    - path: "src/rules/elements.ts"
      provides: "Label transformation for selfOnlyModifiers"
      contains: "combatantName}'s Ability"
  key_links:
    - from: "src/rules/elements.ts"
      to: "activeStatModifiers"
      via: "map with label fallback in updateAbilityBonuses"
      pattern: "label.*combatantName"
---

<objective>
Add default labels to self-targeting stat modifiers in updateAbilityBonuses().

Purpose: Close verification gap where self-targeting modifiers (Stumpy, Bouba, Mayhem, Rozeske, etc.) show generic "Ability" in UI tooltips instead of "[Name]'s Ability".

Output: Updated elements.ts where selfOnlyModifiers get labeled before being added to activeStatModifiers.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/39-unify-ui-breakdown/39-VERIFICATION.md
@src/rules/elements.ts (lines 338-405)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add label transformation for selfOnlyModifiers</name>
  <files>src/rules/elements.ts</files>
  <action>
In updateAbilityBonuses() method (around line 345), the selfOnlyModifiers are currently filtered but not labeled:

```typescript
// CURRENT (line 345):
const selfOnlyModifiers = selfModifiers.filter(m => !m.target || m.target === 'self');
```

Change to map over the filtered modifiers and add default labels:

```typescript
// Filter to self-only modifiers (target undefined or 'self') and add labels
const selfOnlyModifiers = selfModifiers
  .filter(m => !m.target || m.target === 'self')
  .map(m => ({
    ...m,
    label: m.label || `${this.combatantName}'s Ability`,
  }));
```

This ensures:
- Modifiers that already have labels (from registry) keep them
- Modifiers without labels get "[MERC Name]'s Ability" as default
- Consistent with how squad-received modifiers are labeled (lines 382, 388)
  </action>
  <verify>
Run tests to confirm no regressions:
```bash
npm test
```

All 580 tests should pass.

Verify the change is in place:
```bash
grep -A3 "selfOnlyModifiers = selfModifiers" src/rules/elements.ts
```

Should show the .map() chain with label fallback.
  </verify>
  <done>
- selfOnlyModifiers now get labeled with "[MERC Name]'s Ability" when no explicit label
- UI will display proper labels for all 13 self-targeting abilities
- Consistent with squad modifier labeling pattern
  </done>
</task>

</tasks>

<verification>
1. All tests pass: `npm test`
2. Label transformation in place:
   ```bash
   grep "combatantName}'s Ability" src/rules/elements.ts
   ```
   Should show the selfOnlyModifiers line plus the existing squad modifier lines.
3. Self-modifier labeling is consistent with squad-modifier pattern (both use `[Name]'s Ability`)
</verification>

<success_criteria>
- [ ] selfOnlyModifiers mapping includes label fallback
- [ ] Label fallback uses `${this.combatantName}'s Ability`
- [ ] All 580+ tests pass
- [ ] Verification gap closed: self-targeting modifiers now have proper labels
</success_criteria>

<output>
After completion, create `.planning/phases/39-unify-ui-breakdown/39-02-SUMMARY.md`
</output>
