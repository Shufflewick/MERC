---
phase: 02-type-safety-assertions
plan: 03
type: execute
---

<objective>
Fix type assertions in dictator-actions.ts.

Purpose: Eliminate 23 unsafe type assertions in dictator action definitions.
Output: Properly typed dictator-actions.ts using assertion helpers and type narrowing.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./02-03-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-type-safety-assertions/02-01-SUMMARY.md
@.planning/phases/02-type-safety-assertions/02-02-SUMMARY.md

@src/rules/actions/dictator-actions.ts
@src/rules/actions/helpers.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix dictator-actions.ts player assertions</name>
  <files>src/rules/actions/dictator-actions.ts</files>
  <action>
Fix player-related assertions:
- `game.isDictatorPlayer(ctx.player as any)` - Remove unnecessary `as any`
- `ctx.player as any` in condition checks

The `isDictatorPlayer` method accepts `MERCPlayer`. If `ctx.player` is typed differently (e.g., `Player` from framework), either:
1. Cast to `MERCPlayer` (safer than `any`)
2. Use a type assertion helper that validates

Pattern to apply:
```typescript
// Before:
if (!game.isDictatorPlayer(ctx.player as any)) return false;

// After (if ctx.player is Player base type):
if (!game.isDictatorPlayer(ctx.player as MERCPlayer)) return false;

// Or better, if type guard narrows:
if (!ctx.player || !game.isDictatorPlayer(ctx.player)) return false;
```
  </action>
  <verify>`grep -c "as any" src/rules/actions/dictator-actions.ts` is lower than before</verify>
  <done>Player assertions in dictator-actions.ts use proper types instead of `any`</done>
</task>

<task type="auto">
  <name>Task 2: Fix dictator-actions.ts element and args assertions</name>
  <files>src/rules/actions/dictator-actions.ts</files>
  <action>
Fix remaining assertions:
- `element as unknown as TacticsCard` - Use `asTacticsCard(element)` helper
- `element as unknown as Sector` - Use `asSector(element)` helper
- `args.card as TacticsCard` - Use helper or validate
- `args.sector as Sector` - Use helper or validate
- `args.X as string` - Generally safe for string literals, keep if from known sources
- `game.getElementById(id) as Type` - Create typed helper or use existing pattern

For `args.X as Type` where X comes from user choice:
- If it's a string choice (like sector name), assertion is reasonable
- If it's an element reference, use typed helper

For `getElementById`:
```typescript
// Pattern to consider adding if not exists:
function getTypedElement<T>(game: MERCGame, id: number): T | undefined {
  const element = game.getElementById(id);
  return element as T | undefined;
}
```
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `npm test` passes
3. No `as unknown as` patterns remain (or fewer than before)
  </verify>
  <done>dictator-actions.ts assertions fixed using helpers and proper types</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes
- [ ] `npm test` passes
- [ ] No `as any` in dictator-actions.ts
- [ ] Reduced `as unknown as` patterns
</verification>

<success_criteria>

- dictator-actions.ts uses proper type assertions
- No `as any` casts
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-type-safety-assertions/02-03-SUMMARY.md`
</output>
