---
phase: 45-gametable-clean-wiring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ui/components/GameTable.vue
  - src/ui/components/CombatPanel.vue
autonomous: true

must_haves:
  truths:
    - "Combat panel appears when combat starts and disappears when combat ends"
    - "Combat panel displays correct combatant data, health, and casualties during combat"
    - "All decision prompts (target selection, hit allocation, wolverine sixes, attack dog, healing) work correctly"
    - "DictatorPanel and SectorPanel are hidden during active combat"
    - "Game over overlay waits for combat animations to finish before showing"
    - "Fast-forward still works"
  artifacts:
    - path: "src/ui/components/GameTable.vue"
      provides: "Snapshot-driven combat panel visibility, clean wiring"
      contains: "combatSnapshot"
    - path: "src/ui/components/CombatPanel.vue"
      provides: "Snapshot received as prop, no internal combat-panel handler"
      contains: "combatSnapshot"
  key_links:
    - from: "src/ui/components/GameTable.vue"
      to: "combat-panel animation event"
      via: "animationEvents.registerHandler('combat-panel')"
      pattern: "registerHandler.*combat-panel"
    - from: "src/ui/components/GameTable.vue"
      to: "src/ui/components/CombatPanel.vue"
      via: ":combat-snapshot prop"
      pattern: ":combat-snapshot"
    - from: "src/ui/components/CombatPanel.vue"
      to: "src/ui/components/GameTable.vue"
      via: "combat-finished emit triggers snapshot clearing"
      pattern: "combat-finished"
---

<objective>
Clean up GameTable's combat panel wiring and move snapshot ownership to GameTable.

Purpose: GameTable currently has ~150 lines of combat script (10 refs, 6 watchers, 4 dead handlers) that was a multi-layered fallback system for theatre-view combat state. Phase 44 made CombatPanel self-contained (renders 100% from animation events), so all of this is vestigial. This plan replaces it with ~15 lines: a single snapshot ref, a handler registration, and a computed.

Output: GameTable's combat section is under 20 lines of template and under 10 lines of script logic. CombatPanel receives its snapshot as a prop instead of managing its own handler.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/45-gametable-clean-wiring/45-RESEARCH.md
@.planning/phases/44-combatpanel-rebuild/44-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite GameTable combat section -- snapshot ref replaces fallback chains</name>
  <files>src/ui/components/GameTable.vue</files>
  <action>
Rewrite the combat panel section of GameTable.vue (lines ~484-725 and template lines ~1253-1278).

**Add (the new combat section, ~15 lines of script):**

1. Create a `combatSnapshot` ref: `const combatSnapshot = ref<Record<string, unknown> | null>(null);`

2. Register a `combat-panel` animation event handler on the existing `animationEvents` composable (already imported at line 491). The handler sets `combatSnapshot.value = event.data as Record<string, unknown>;`. This must be inside the existing `if (animationEvents)` guard or create a new one near line 491.

3. Replace `hasActiveCombat` computed with: `computed(() => combatSnapshot.value !== null)`. This computed is used by DictatorPanel (line 1284) and SectorPanel (line 1296) in their v-if conditions, so the name `hasActiveCombat` must be preserved.

4. Rewrite `handleCombatFinished` to: clear `combatSnapshot.value = null`, then try/catch `await props.actionController.execute('clearCombatAnimations', {})`. The comment on the state machine reference ("emitted by CombatPanel after its state machine reaches COMPLETE") should be updated to say "emitted by CombatPanel after combat-end animation finishes".

**Delete (all fallback chain code):**

These refs/computeds -- delete declarations and all usages:
- `combatPanelReady` (line 488)
- `rawAnimationEvents` (lines 493-497)
- `combatEventSeen` (line 499)
- `lastCombatEventId` (line 500)
- `hasPendingCombatEvents` (lines 514-517) -- verify `showGameOverOverlay` does NOT depend on it (it reads `animationEvents?.isAnimating` and `animationEvents?.pendingCount` directly, confirmed in research)
- `theatreActiveCombat` (lines 520-525)
- `activeCombat` computed (lines 527-529) -- NOT the `activeCombatForPanel`, that uses this
- `cachedCombat` (line 531)
- `activeCombatForPanel` (lines 545-549)
- `combatSectorName` (lines 629-633)

These watchers -- delete entirely:
- `watch(rawAnimationEvents, ...)` (lines 502-512)
- `watch(activeCombat, ...)` (lines 533-537)
- `watch([activeCombat, hasPendingCombatEvents], ...)` (lines 539-543)
- Pause-on-combat-start watcher (lines 562-580)
- Unpause-on-ready watcher (lines 582-595)
- `watch([hasPendingCombatEvents, activeCombatForPanel], ...)` (lines 597-604)

These dead handler functions -- delete entirely:
- `handleCombatPanelReady` (lines 723-725)
- `handleAllocateHit` (lines 637-640) -- body is a comment, no-op
- `handleAllocateWolverineSix` (lines 643-645) -- body is a comment, no-op
- `handleDisplayComplete` (lines 718-721) -- `display-complete` is never emitted by CombatPanel

Keep the section comment banner `// COMBAT PANEL` and the `// ANIMATION EVENTS SETUP` banner can be removed or consolidated since the new code is much shorter.

Keep `showGameOverOverlay` (lines 607-615) -- it does NOT depend on any deleted refs.

Keep ALL action handler functions: `handleReroll`, `handleConfirmAllocation`, `handleConfirmTargets`, `handleContinueCombat`, `handleRetreatCombat`, `handleSelectRetreatSector`, `handleAssignAttackDog`, `handleUseMedicalKit`, `handleUseSurgeonHeal`, `handleUseBeforeAttackHeal`, `handleSkipBeforeAttackHeal`.

**Update template (lines ~1253-1278):**

Replace the CombatPanel binding with:
```html
<!-- Combat Panel - shown when combat snapshot is present -->
<CombatPanel
  v-if="hasActiveCombat"
  :combat-snapshot="combatSnapshot"
  :is-my-turn="isMyTurn"
  :available-actions="availableActions"
  :is-selecting-retreat-sector="isSelectingRetreatSector"
  :retreat-sector-choices="retreatSectorChoices"
  @reroll="handleReroll"
  @confirm-allocation="handleConfirmAllocation"
  @confirm-targets="handleConfirmTargets"
  @continue-combat="handleContinueCombat"
  @retreat-combat="handleRetreatCombat"
  @select-retreat-sector="handleSelectRetreatSector"
  @assign-attack-dog="handleAssignAttackDog"
  @combat-finished="handleCombatFinished"
  @use-medical-kit="handleUseMedicalKit"
  @use-surgeon-heal="handleUseSurgeonHeal"
  @use-before-attack-heal="handleUseBeforeAttackHeal"
  @skip-before-attack-heal="handleSkipBeforeAttackHeal"
/>
```

Removed from template: `:active-combat`, `:sector-name`, `@allocate-hit`, `@allocate-wolverine-six`, `@display-complete`, `@panel-ready`.
Kept: `@select-retreat-sector` (real handler for retreat wizard).
Added: `:combat-snapshot`.
  </action>
  <verify>
1. `npx vue-tsc --noEmit` passes (no type errors in GameTable.vue)
2. Grep for deleted refs returns zero hits: `grep -n 'combatPanelReady\|rawAnimationEvents\|combatEventSeen\|lastCombatEventId\|theatreActiveCombat\|cachedCombat\|activeCombatForPanel\|combatSectorName' src/ui/components/GameTable.vue` should return nothing
3. Grep for deleted handlers returns zero hits: `grep -n 'handleCombatPanelReady\|handleAllocateHit\|handleAllocateWolverineSix\|handleDisplayComplete' src/ui/components/GameTable.vue` should return nothing
4. `hasActiveCombat` still exists and is computed from `combatSnapshot`
5. `combatSnapshot` ref exists with `combat-panel` handler registration
6. `showGameOverOverlay` still exists and reads from `animationEvents` directly
  </verify>
  <done>
GameTable combat section is ~15 lines of script (snapshot ref, handler, computed, handleCombatFinished). Template CombatPanel binding has no dead props or event handlers. All fallback chain code is deleted. DictatorPanel and SectorPanel still reference hasActiveCombat.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update CombatPanel to receive snapshot as prop</name>
  <files>src/ui/components/CombatPanel.vue</files>
  <action>
Update CombatPanel.vue to receive the combat snapshot as a prop from GameTable instead of managing its own handler.

**Replace props (lines 37-98):**

Remove the entire `activeCombat` prop type (62-line inline type definition) and the `sectorName` prop. Replace with:

```typescript
const props = defineProps<{
  combatSnapshot: Record<string, unknown> | null;
  isMyTurn: boolean;
  availableActions: string[];
  isSelectingRetreatSector?: boolean;
  retreatSectorChoices?: RetreatSector[];
}>();
```

**Update emits (lines 100-116):**

Remove these emits from `defineEmits`:
- `allocate-hit` -- GameTable handler was a no-op
- `allocate-wolverine-six` -- GameTable handler was a no-op
- `panel-ready` -- no pause/resume mechanism

Keep all other emits: `reroll`, `confirm-allocation`, `confirm-targets`, `continue-combat`, `retreat-combat`, `select-retreat-sector`, `assign-attack-dog`, `combat-finished`, `use-medical-kit`, `use-surgeon-heal`, `use-before-attack-heal`, `skip-before-attack-heal`.

**Remove internal `combat-panel` handler (lines 227-230):**

Delete the `animationEvents.registerHandler('combat-panel', ...)` block. The snapshot now comes from the prop. All other animation event handlers (`combat-roll`, `combat-damage`, `combat-death`, `combat-round-start`, `combat-end`, `combat-attack-dog`, `combat-heal`) stay exactly as they are.

**Remove the internal `combatSnapshot` ref (line 149):**

Delete `const combatSnapshot = ref<Record<string, unknown> | null>(null);`. All existing code that reads `combatSnapshot.value` must now read `props.combatSnapshot` instead.

**Update all references from `combatSnapshot.value` to `props.combatSnapshot`:**

- `displayCombat` computed (line 377): `computed(() => props.combatSnapshot)`
- `livingRebels` computed (line 407-422): `const snapshot = props.combatSnapshot;`
- `livingDictator` computed (line 425-440): `const snapshot = props.combatSnapshot;`
- Snapshot decision context computeds (lines 443-447): `props.combatSnapshot?.pendingTargetSelection`, etc.
- `watch(() => combatSnapshot.value?.pendingTargetSelection, ...)` (line 615): change to `watch(() => props.combatSnapshot?.pendingTargetSelection, ...)`

**Replace the `watch(() => props.activeCombat, ...)` watcher (lines 379-386):**

This watcher resets UI state when combat starts. Replace with a watcher on the snapshot prop:

```typescript
watch(() => props.combatSnapshot, (newSnapshot, oldSnapshot) => {
  if (newSnapshot && newSnapshot !== oldSnapshot) {
    healthOverrides.value.clear(); // Snapshot health is authoritative at decision points
  }
  if (newSnapshot && !oldSnapshot) {
    // New combat starting -- reset all UI state
    resetAnimations();
    healingCombatants.value.clear();
  }
});
```

**Update `combat-end` handler (lines 270-279):**

Remove line 274 (`combatSnapshot.value = null;`) -- GameTable clears the snapshot when it receives `combat-finished`. Keep everything else: visual animation display, healthOverrides clear, healingCombatants clear, resetAnimations, and `emit('combat-finished')`.

```typescript
animationEvents.registerHandler('combat-end', async (event) => {
  currentEvent.value = mapEventToDisplayState(event);
  await sleep(getTiming('combat-end'));
  // Cleanup UI state -- GameTable clears the snapshot via combat-finished handler
  healthOverrides.value.clear();
  healingCombatants.value.clear();
  resetAnimations();
  emit('combat-finished');
});
```

**Remove `onMounted` emit (lines 312-314):**

Delete the `onMounted(() => { emit('panel-ready'); });` block. There is no pause/resume mechanism to signal.

**Remove `allocate-wolverine-six` emit call (line 582):**

In the `selectTarget` function, the Wolverine sixes branch (line 580-583) emits `allocate-wolverine-six`. Since Wolverine 6s allocation is tracked internally in CombatPanel (via selectedTargets and the hit allocation panel) and the final allocation is submitted via `confirm-targets`, this emit is a no-op. Remove the emit call. The Wolverine sixes branch should still track the selection locally -- look at what the surrounding code does and keep the selection logic, just remove the `emit('allocate-wolverine-six', normalized)` line. If the branch has no other logic besides the emit, add a comment: `// Wolverine 6s tracked via hit allocation panel -- no action needed on individual click`.

**Update template `sectorName` reference (line 697):**

The template has `{{ sectorName }}` in the header. Since `sectorName` is no longer a prop, add a computed:

```typescript
const sectorName = computed(() => (props.combatSnapshot?.sectorName as string) ?? 'Unknown');
```

**Remove `allocate-hit` emit calls if any exist:**

Search for `emit('allocate-hit'` in the file. If found, remove those calls (they were no-ops on the GameTable side).

Keep `onUnmounted` cleanup (lines 687-690) as-is -- it runs after GameTable clears the snapshot and CombatPanel unmounts.
  </action>
  <verify>
1. `npx vue-tsc --noEmit` passes (no type errors in CombatPanel.vue)
2. Grep for removed items returns zero: `grep -n 'activeCombat\|panel-ready\|allocate-hit\|allocate-wolverine-six' src/ui/components/CombatPanel.vue` should return nothing (except possibly comments)
3. `props.combatSnapshot` is used throughout (not a local ref)
4. No `registerHandler('combat-panel'` in CombatPanel.vue
5. `combat-end` handler does NOT clear combatSnapshot (no `combatSnapshot.value = null`)
6. `sectorName` computed reads from `props.combatSnapshot.sectorName`
7. `onMounted` block with `panel-ready` emit is gone
  </verify>
  <done>
CombatPanel receives snapshot as a prop. No internal combat-panel handler. No activeCombat prop. No sectorName prop. healthOverrides cleared via snapshot watcher. combat-end handler keeps visual animation but lets GameTable clear the snapshot. All dead emits removed.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. `npx vue-tsc --noEmit` passes with zero errors
2. GameTable combat script section is under 20 lines (snapshot ref + handler + hasActiveCombat computed + handleCombatFinished)
3. GameTable combat template section is under 22 lines (CombatPanel binding with remaining event handlers)
4. Zero references to deleted items in GameTable: `combatPanelReady`, `rawAnimationEvents`, `combatEventSeen`, `lastCombatEventId`, `theatreActiveCombat`, `cachedCombat`, `activeCombatForPanel`, `combatSectorName`, `handleCombatPanelReady`, `handleAllocateHit`, `handleAllocateWolverineSix`, `handleDisplayComplete`
5. Zero references to `activeCombat` as a prop name in CombatPanel.vue
6. `hasActiveCombat` in GameTable checks `combatSnapshot.value !== null`
7. CombatPanel has NO `registerHandler('combat-panel')` call
8. CombatPanel `combat-end` handler emits `combat-finished` but does NOT set `combatSnapshot` to null
9. Both DictatorPanel and SectorPanel still reference `!hasActiveCombat` in their v-if conditions
10. `showGameOverOverlay` is unchanged and functional

**Requirements covered:**
- UI-04: GameTable clean wiring (snapshot-driven visibility, no fallback chains, no cached state, no pause-until-mount)
- DELETE-04: All fallback refs/watchers/handlers removed from GameTable
</verification>

<success_criteria>
- Combat panel visibility driven by `combatSnapshot !== null` -- single condition, no fallback chains
- Zero vestigial refs: combatEventSeen, lastCombatEventId, cachedCombat, activeCombatForPanel, theatreActiveCombat, combatPanelReady
- Zero dead handlers: handleAllocateHit, handleAllocateWolverineSix, handleDisplayComplete, handleCombatPanelReady
- Zero pause/resume watchers
- GameTable combat script under 20 lines, template under 22 lines
- CombatPanel receives snapshot as prop, no internal combat-panel handler
- TypeScript compiles clean
</success_criteria>

<output>
After completion, create `.planning/phases/45-gametable-clean-wiring/45-01-SUMMARY.md`
</output>
