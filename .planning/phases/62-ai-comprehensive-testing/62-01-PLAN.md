---
phase: 62-ai-comprehensive-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/helpers/auto-play.ts
  - tests/dictator-abilities.test.ts
autonomous: true

must_haves:
  truths:
    - "Shared autoResolveArgs and getCurrentAction helpers exist in one place"
    - "Each of the 9 expansion dictator per-turn abilities has a passing unit test"
    - "Unit tests verify observable state changes (MERC hired, militia placed, damage spread, etc.)"
  artifacts:
    - path: "tests/helpers/auto-play.ts"
      provides: "Shared autoResolveArgs, getCurrentAction, getPlayerAction helpers"
      exports: ["autoResolveArgs", "getCurrentAction", "getPlayerAction"]
    - path: "tests/dictator-abilities.test.ts"
      provides: "Unit tests for all 9 expansion dictator per-turn ability functions"
      min_lines: 200
  key_links:
    - from: "tests/helpers/auto-play.ts"
      to: "boardsmith/runtime"
      via: "MERCGame type import"
      pattern: "import.*MERCGame"
    - from: "tests/dictator-abilities.test.ts"
      to: "src/rules/dictator-abilities.ts"
      via: "direct function imports"
      pattern: "import.*apply.*Ability.*dictator-abilities"
---

<objective>
Extract duplicated test helpers into a shared module and write unit tests for all 9 expansion dictator per-turn abilities.

Purpose: Eliminate triple-duplication of autoResolveArgs/getCurrentAction across test files, and verify each dictator's turn ability produces correct game state changes when called directly.

Output: `tests/helpers/auto-play.ts` shared helpers + `tests/dictator-abilities.test.ts` with 9 per-turn ability test suites.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/62-ai-comprehensive-testing/62-RESEARCH.md

@tests/combat-barriers.test.ts (autoResolveArgs + getCurrentAction source, lines 26-108)
@tests/ai-rebel-batching.test.ts (duplicate autoResolveArgs + getCurrentAction + getPlayerAction)
@tests/mcts-clone.test.ts (duplicate autoResolveArgs)
@src/rules/dictator-abilities.ts (all ability functions to test)
@src/rules/game.ts (MERCGame, MERCPlayer types)
@src/rules/elements.ts (CombatantModel, Sector, Equipment)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract shared test helpers</name>
  <files>tests/helpers/auto-play.ts</files>
  <action>
Create `tests/helpers/auto-play.ts` exporting the shared helper functions currently duplicated across combat-barriers.test.ts, ai-rebel-batching.test.ts, and mcts-clone.test.ts:

1. `autoResolveArgs(game: MERCGame, actionName: string, playerSeat: number): Record<string, unknown> | null` - Copy from combat-barriers.test.ts lines 26-87 exactly (the most complete version).

2. `getCurrentAction(flowState: any): { currentPlayer: number; available: string[] } | null` - Copy from combat-barriers.test.ts lines 93-108.

3. `getPlayerAction(flowState: any, playerSeat: number): { available: string[] } | null` - Copy from ai-rebel-batching.test.ts lines 108-117.

4. `playUntilComplete(runner: GameRunner<MERCGame>, maxActions?: number): { actionCount: number; completed: boolean }` - A new helper that auto-plays through all actions until game completes or maxActions reached. Use the pattern from ai-rebel-batching.test.ts `playUntilRebelActions` but without the stopping condition (just play until flowState.complete or no more actions). This is needed for integration tests in Plan 03.

Import types from `boardsmith/runtime` (GameRunner) and `../../src/rules/game.js` (MERCGame).

Do NOT update existing test files to use the shared helpers yet - that's out of scope (existing tests work fine with their copies).
  </action>
  <verify>
`npx vitest run tests/helpers/auto-play.ts --passWithNoTests` - file compiles without errors. Also verify with `npx tsc --noEmit tests/helpers/auto-play.ts` or equivalent type check.
  </verify>
  <done>Shared helpers file exists at tests/helpers/auto-play.ts with all 4 exported functions, compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for 9 expansion dictator per-turn abilities</name>
  <files>tests/dictator-abilities.test.ts</files>
  <action>
Create `tests/dictator-abilities.test.ts` with unit tests for all 9 expansion dictator per-turn ability functions. Use `createTestGame` from `boardsmith/testing` for game setup.

**IMPORTANT:** Use the internal combatant IDs (from data/combatants.json), NOT display names:
- `gadafi` (not gaddafi), `hitler`, `hussein`, `mao`, `mussolini`, `noriega`, `pinochet`, `polpot`, `stalin`

**Test structure:** One `describe` block per dictator, each with 1-2 `it` blocks testing the core behavior.

For each dictator, the pattern is:
1. Create test game with `createTestGame(MERCGame, { playerCount: 2, playerNames: ['Rebel1', 'Dictator'], seed: '...' })`
2. Get `game = testGame.game`
3. Set up the dictator: the game defaults to Castro. To test a specific dictator, you need to check how `setupDictator` or dictator selection works. The ability functions take `game: MERCGame` and check `game.dictatorPlayer.dictator.combatantId` internally, so you may need to set the dictator identity. Read the top of `dictator-abilities.ts` and `game.ts` to find the correct setup method. The `dictatorChoice` option in GameRunner gameOptions (see ai-rebel-batching.test.ts line 142 pattern) or `game.dictatorPlayer.dictator.combatantId` assignment may be needed.
4. Set up required game state (rebel-controlled sectors, MERC deck population, etc.)
5. Call the ability function directly
6. Assert state changes

**Per-dictator test specs:**

**Gaddafi** (`applyGadafiTurnAbility`): Verify hired MERC count increases by 1 after call. Seed: `gadafi-turn-test`.

**Hitler** (`applyHitlerTurnAbility`): Verify hired MERC count increases by 1, and `game.hitlerInitiativeTargetSeat` is set to a valid rebel seat. Seed: `hitler-turn-test`.

**Hussein** (`applyHusseinBonusTactics`): Verify a tactics card is played (check game state changes from tactics card application). Seed: `hussein-turn-test`.

**Mao** (`applyMaoTurnAbility`): Verify militia are placed in wilderness sectors. Count militia before and after. Need at least 1 rebel-controlled sector for the ability to have effect. Seed: `mao-turn-test`.

**Mussolini** (`applyMussoliniTurnAbility`): Verify militia are added to a dictator-controlled sector and spread to adjacent. Seed: `mussolini-turn-test`.

**Noriega** (`applyNoriegaTurnAbility`): Verify militia conversion from rebel sectors and placement. Need rebel sectors with militia. Seed: `noriega-turn-test`.

**Pinochet** (`applyPinochetTurnAbility`): Calls `applyPinochetDamageSpread` + `applyPinochetPendingHires`. Verify damage is spread across rebel forces when rebel-controlled sectors exist. Seed: `pinochet-turn-test`.

**Pol Pot** (`applyPolpotTurnAbility`): Verify militia placed in a rebel-controlled sector. Need rebel-controlled sectors. Seed: `polpot-turn-test`.

**Stalin** (`applyStalinTurnAbility`): Verify hired MERC count increases by 1 (primary squad). Seed: `stalin-turn-test`.

**Key constraint:** These functions may require the dictator player to have `isAI = true` to follow the AI path (see Research pitfall 2). If the function checks `game.dictatorPlayer.isAI`, ensure it's set. You may need to use GameRunner instead of createTestGame if createTestGame doesn't support `isAI` on dictator.

**Key constraint:** Some abilities require game state that only exists after Day 1 (rebel-controlled sectors, existing militia). Read each ability function to understand preconditions. For abilities that need sectors, manually set sector control: find sectors via `game.gameMap.getAllSectors()` and set their control state.

Each test should have clear assertions on observable state changes. If an ability function returns `DictatorAbilityResult`, assert `result.success === true` (or check the actual return shape).
  </action>
  <verify>`npx vitest run tests/dictator-abilities.test.ts` - all tests pass.</verify>
  <done>All 9 expansion dictator per-turn abilities have passing unit tests that verify correct state mutations.</done>
</task>

</tasks>

<verification>
- `npx vitest run tests/helpers/auto-play.ts tests/dictator-abilities.test.ts` passes all tests
- Shared helpers file exports autoResolveArgs, getCurrentAction, getPlayerAction, playUntilComplete
- Each dictator has at least one test verifying their per-turn ability's core behavior
</verification>

<success_criteria>
- tests/helpers/auto-play.ts exists with 4 exported functions
- tests/dictator-abilities.test.ts has 9 describe blocks (one per expansion dictator) with passing tests
- All tests verify observable game state changes, not just "no errors"
</success_criteria>

<output>
After completion, create `.planning/phases/62-ai-comprehensive-testing/62-01-SUMMARY.md`
</output>
