---
phase: 11-migrate-instanceof
plan: 01
type: execute
---

<objective>
Create type guards and migrate combat.ts from instanceof checks to property-based type guards.

Purpose: Eliminate 56 instanceof MercCard/DictatorCard checks in combat.ts using the new isMerc/isDictator properties.
Output: Type guards in helpers.ts, combat.ts using property-based checks.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-unified-class/10-01-SUMMARY.md

@src/rules/elements.ts
@src/rules/combat.ts
@src/rules/actions/helpers.ts
@src/rules/combat-types.ts

**Prior decisions:**
- CombatUnitCard has isMerc/isDictator getters
- MercCard/DictatorCard extend CombatUnitCard
- sourceElement typed as `MercCard | DictatorCard | null`
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add isCombatUnitCard type guard to helpers.ts</name>
  <files>src/rules/actions/helpers.ts</files>
  <action>
Add a type guard function `isCombatUnitCard` that checks for the presence of the `isMerc` property (which exists on CombatUnitCard and its subclasses). This enables property-based type checking instead of instanceof.

```typescript
/**
 * Type guard to check if an element is a CombatUnitCard (MercCard or DictatorCard).
 * Uses property check instead of instanceof for bundler compatibility.
 */
export function isCombatUnitCard(element: unknown): element is CombatUnitCard {
  return element !== null &&
         typeof element === 'object' &&
         'isMerc' in element &&
         typeof (element as CombatUnitCard).isMerc === 'boolean';
}
```

Also add import for CombatUnitCard. Update the existing `isDictatorCard` function to use property check:

```typescript
export function isDictatorCard(unit: unknown): unit is DictatorCard {
  return isCombatUnitCard(unit) && unit.isDictator;
}
```

Add a `isMercCard` type guard as well:

```typescript
export function isMercCard(unit: unknown): unit is MercCard {
  return isCombatUnitCard(unit) && unit.isMerc;
}
```
  </action>
  <verify>npm run build passes, grep for "isCombatUnitCard" shows function exists</verify>
  <done>Type guards added to helpers.ts, existing isDictatorCard updated</done>
</task>

<task type="auto">
  <name>Task 2: Migrate combat.ts instanceof checks to property-based guards</name>
  <files>src/rules/combat.ts</files>
  <action>
Replace all 56 `instanceof MercCard` and `instanceof DictatorCard` checks with property-based checks using the `isMerc`/`isDictator` properties.

**Pattern 1: Simple type check and mercId access**
Before:
```typescript
if (combatant.sourceElement instanceof MercCard) {
  return combatant.sourceElement.mercId === 'lucid';
}
```
After:
```typescript
if (combatant.sourceElement?.isMerc) {
  return combatant.sourceElement.unitId === 'lucid';
}
```

Note: Use `unitId` instead of `mercId` since CombatUnitCard uses unified property names. The `mercId` getter on MercCard still works but `unitId` is the canonical property.

**Pattern 2: Ternary with MercCard check**
Before:
```typescript
const mercId = combatant.sourceElement instanceof MercCard
  ? combatant.sourceElement.mercId
  : undefined;
```
After:
```typescript
const mercId = combatant.sourceElement?.isMerc
  ? combatant.sourceElement.unitId
  : undefined;
```

**Pattern 3: MercCard type narrowing for property access**
Before:
```typescript
if (combatant.sourceElement instanceof MercCard) {
  const merc = combatant.sourceElement;
  return merc.armorSlot !== undefined;
}
```
After:
```typescript
if (combatant.sourceElement?.isMerc) {
  return combatant.sourceElement.armorSlot !== undefined;
}
```

**Pattern 4: Else-if DictatorCard**
Before:
```typescript
if (combatant.sourceElement instanceof MercCard) {
  // merc handling
} else if (combatant.sourceElement instanceof DictatorCard) {
  // dictator handling
}
```
After:
```typescript
if (combatant.sourceElement?.isMerc) {
  // merc handling
} else if (combatant.sourceElement?.isDictator) {
  // dictator handling
}
```

**Pattern 5: Property check fallback (bundler compat)**
Before:
```typescript
const hasMercSource = attacker.sourceElement instanceof MercCard ||
                      (attacker.sourceElement && 'mercId' in attacker.sourceElement);
```
After:
```typescript
const hasMercSource = attacker.sourceElement?.isMerc ?? false;
```

Apply these patterns to all 56 occurrences. The key transformations:
- `instanceof MercCard` → `.isMerc`
- `instanceof DictatorCard` → `.isDictator`
- `.mercId` → `.unitId` (when accessed through type guard)
- `.dictatorId` → `.unitId` (when accessed through type guard)
- Remove redundant fallback 'mercId' in checks (now use isMerc)
  </action>
  <verify>npm run build passes, npm test passes, grep for "instanceof MercCard" in combat.ts shows 0 results</verify>
  <done>All instanceof checks in combat.ts replaced with property-based checks, tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm test` passes (may have pre-existing failures)
- [ ] `grep -c "instanceof MercCard" src/rules/combat.ts` returns 0
- [ ] `grep -c "instanceof DictatorCard" src/rules/combat.ts` returns 0
- [ ] Type guards exported from helpers.ts
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No new TypeScript errors introduced
- combat.ts uses property-based type guards exclusively
</success_criteria>

<output>
After completion, create `.planning/phases/11-migrate-instanceof/11-01-SUMMARY.md`
</output>
